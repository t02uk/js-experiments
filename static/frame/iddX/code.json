{"source":{"css":"* {\r\n    margin:0px; padding: 0px;\r\n}\r\nbody {\r\n    background-color: #885;\r\n    overflow: hidden;\r\n}\r\n\r\n","html":"<!--\r\njsdo.itでCoffeeScriptを試す場合のデモです\r\nJavaScript領域に前後を/*と*/でくくってCoffeeScriptを記述してください\r\njQueryが使用できます（他に必要なライブラリがあれば「＋」から読みこめば実行できます）\r\n-->\r\n<script src=\"http://coffeescript.org/extras/coffee-script.js\"></script>\r\n<script src=\"http://jsrun.it/lib/prototype-1.6.1/js\"></script>\r\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js\"></script>\r\n<script>\r\n$(function () {\r\n  var js = CoffeeScript.compile(jQuery('script:last').text().replace(/^[\\s\\S]*?\\/\\*/, '').replace(/\\*\\/\\s*$/, ''));\r\n  eval(js)\r\n});\r\n</script>\r\n<canvas id='world'></canvas>","lisence":"MIT","js":"// forked from kyo_ago's \"CoffeeScript出来るかな\" http://jsdo.it/kyo_ago/gAoN\r\n//以下のコメントアウト内にCoffeeScriptを記述してください。\r\n//コード開始から/＊までは無視されます。\r\n/*\r\nwindow.onload = ->\r\n\r\n  # セル数\r\n  cap = 24\r\n  # セルの状態が次の状態へ移る時の描画間隔\r\n  drawInteval = 4\r\n\r\n  d = new DCore()\r\n\r\n  # 任意関数オブジェクトのメモ化\r\n  memoize = (f, memo={}) -> () ->\r\n    key = $A(arguments).join()\r\n    if memo[key]? then memo[key]\r\n    else memo[key] = f.apply(null, $A(arguments))\r\n\r\n  # セル。一マスに相当\r\n  class Cell\r\n    constructor: ->\r\n      # 生きているか, 描画座標[x, y]\r\n      [@active, @x, @y] = $A(arguments)\r\n    # 与えられた座標をもとに、自分自身か否かを返す\r\n    eq: (x, y) ->\r\n      @x is x and @y is y\r\n    # 前回の状態を保存\r\n    saveMemento: ->\r\n      @preactive = @active\r\n\r\n  # セルを生成\r\n  cells = $R(0, cap, true).map((y)->\r\n    $R(0, cap, true).map((x) ->\r\n      new Cell(!$R(0, 2).rand(), x, y)\r\n    )\r\n  )\r\n\r\n  # セルの描画処理。。。に使用するバッファを返す\r\n  # 描画処理の高速化のためメモ化して使用することを前提とし、\r\n  # キャッシュにヒットしやすくするため描画範囲が特殊\r\n  # セルとセルの隙間を中心に、左上、右上、左下、右下のそれぞれ\r\n  # 四分の一ずつ描くイメージ\r\n  #  n1-n4 => それぞれ左上、右上、左下、右下が現在生きているか\r\n  #  o1-o4 => それぞれ左上、右上、左下、右下が前回生きていたか\r\n  #  step  => セルの状態移行ステップ\r\n  drawing = (n1, n2, n3, n4, o1, o2, o3, o4, step) ->\r\n    rstep = 1 - step\r\n    size = 16\r\n    shift = 6\r\n    recp = 1 / size\r\n    sd = d.subTexture(size, size)\r\n    img = sd.ctx.createImageData(size, size)\r\n    $R(0, size, true).map((ax) ->\r\n      $R(0, size, true).map((ay) ->\r\n        x = ax * recp\r\n        y = ay * recp\r\n\r\n        c = 0\r\n        c += 1 / (     x  *      x +       y *       y ) if n1 and o1\r\n        c += 1 / ((1 - x) * (1 - x) +      y  *      y ) if n2 and o2\r\n        c += 1 / (     x  *      x  + (1 - y) * (1 - y)) if n3 and o3\r\n        c += 1 / ((1 - x) * (1 - x) + (1 - y) * (1 - y)) if n4 and o4\r\n\r\n        c += step / (     x  *      x +       y *       y ) if n1 and not o1\r\n        c += step / ((1 - x) * (1 - x) +      y  *      y ) if n2 and not o2\r\n        c += step / (     x  *      x  + (1 - y) * (1 - y)) if n3 and not o3\r\n        c += step / ((1 - x) * (1 - x) + (1 - y) * (1 - y)) if n4 and not o4\r\n\r\n        c += rstep / (     x  *      x +       y *       y ) if not n1 and o1\r\n        c += rstep / ((1 - x) * (1 - x) +      y  *      y ) if not n2 and o2\r\n        c += rstep / (     x  *      x  + (1 - y) * (1 - y)) if not n3 and o3\r\n        c += rstep / ((1 - x) * (1 - x) + (1 - y) * (1 - y)) if not n4 and o4\r\n\r\n        col = if c > 3 then [0x99, 0xa0, 0x73] else [0xff, 0xff, 0xd5]\r\n\r\n        i = (ax + ay * size) * 4\r\n        img.data[i + 0] = col[0]\r\n        img.data[i + 1] = col[1]\r\n        img.data[i + 2] = col[2]\r\n        img.data[i + 3] = 0xff\r\n      )\r\n    )\r\n    sd.ctx.putImageData(img, 0, 0)\r\n    sd\r\n\r\n  memodDrawing = memoize(drawing)\r\n\r\n  # 隣接するセルを求める　だいぶ手抜き\r\n  flattened = cells.flatten()\r\n  flattened.each((e1) ->\r\n    e1.neighbor = flattened.select((e2) ->\r\n      e2.eq(e1.x - 1, e1.y - 1) or\r\n      e2.eq(e1.x + 1, e1.y - 1) or\r\n      e2.eq(e1.x    , e1.y - 1) or\r\n      e2.eq(e1.x - 1, e1.y    ) or\r\n      e2.eq(e1.x + 1, e1.y    ) or\r\n      e2.eq(e1.x    , e1.y + 1) or\r\n      e2.eq(e1.x - 1, e1.y + 1) or\r\n      e2.eq(e1.x + 1, e1.y + 1)\r\n    )\r\n  )\r\n\r\n  # メインループここから\r\n  ((c) ->\r\n\r\n    #\r\n    (() ->\r\n      # セルの次の状態を求める。(true or false)\r\n      cells.map((e) ->\r\n        e.map((e) ->\r\n          e.saveMemento()\r\n          numActive = e.neighbor.select((e) -> e.active).length\r\n\r\n          if not e.active and numActive is 3 then true\r\n          else if e.active and 2 <= numActive <= 3 then true\r\n          else if e.active and numActive <= 1 then false\r\n          else if e.active and numActive >= 4 then false\r\n          else e.active\r\n        )\r\n      # 求めた状態をそれぞれのセルへ適用\r\n      ).zip2(cells, (e) ->\r\n        e[1].zip(e[0], (ee) ->\r\n          ee[0].active = ee[1]\r\n        )\r\n      )\r\n    )() if c % drawInteval is 0\r\n\r\n    #d\r\n    # .blend(\"copy\")\r\n    # .alpha(1.0)\r\n    # .rgb(0xff, 0xff, 0xff)\r\n    # .fillBack()\r\n\r\n    # 描画処理 injectなのに純関数じゃないのは気にしない\r\n    cells.inject(false, (left, right) ->\r\n      unless left then right\r\n      else\r\n        left.zip2(right).inject(false, (left, right) ->\r\n          unless left then right\r\n          else\r\n            x = (left[0].x + right[0].x) / 2 / cap\r\n            y = (left[0].y +  left[1].y) / 2 / cap\r\n            sd = memodDrawing(\r\n              left[0].active, right[0].active,\r\n              left[1].active, right[1].active,\r\n              left[0].preactive, right[0].preactive,\r\n              left[1].preactive, right[1].preactive,\r\n              (c / drawInteval) % 1\r\n            )\r\n            d\r\n             .blend(\"source-over\")\r\n             .alpha(1.0)\r\n             .drawImage(sd, [x, y], [1 / cap, 1 / cap])\r\n\r\n            right\r\n        )\r\n      right\r\n    )\r\n    window.setTimeout(arguments.callee.curry(c + 1), 33)\r\n  )(0)\r\n*/\r\n\r\n"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/i/d/d/iddX_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/i/d/d/iddX.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/i/d/d/iddX_100.jpg"},"description_html":"タモツくん<br />\r\n<br />\r\n参考：<br />\r\n<a  href=\"http://www.amazon.co.jp/%E6%B2%BC%E5%9C%B0%E3%81%AE%E3%81%82%E3%82%8B%E6%A3%AE%E3%82%92%E6%8A%9C%E3%81%91%E3%81%A6-%E6%A2%A8%E6%9C%A8-%E9%A6%99%E6%AD%A9/dp/4104299057\">http://www.amazon.co.jp/%E6%B2%BC%E5%9C%B0%E3%81%AE%E3%81%82%E3%82%8B%E6%A3%AE%E3%82%92%E6%8A%9C%E3%81%91%E3%81%A6-%E6%A2%A8%E6%9C%A8-%E9%A6%99%E6%AD%A9/dp/4104299057</a>","parent":{"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/g/A/o/gAoN_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/g/A/o/gAoN.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/g/A/o/gAoN_100.jpg"},"modified_date":"2011-03-10 16:26:19","uid":"gAoN","created_date":"2011-03-10 15:36:25","path":"gAoN","description":"JSのコード部分に前後を/*と*/でくくったCoffeeScriptを記述するとresultに実行結果、codeにコンパイル後のJSを出力します。\n（//forked fromとかはあっても大丈夫です）","statistic":{"forked":"74","favorite":"8","pageview":"124260"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/4/f/4/0/4f404b86e6ba1fbb2ea71bed4f9241a1b840bd88_100.jpg","name":"kyo_ago"},"url":"http://jsdo.it/kyo_ago/gAoN","title":"CoffeeScript出来るかな"},"modified_date":"2016-01-17 21:30:11","uid":"iddX","created_date":"2011-05-07 01:37:15","path":"iddX","description":"タモツくん\r\n\r\n参考：\r\nhttp://www.amazon.co.jp/%E6%B2%BC%E5%9C%B0%E3%81%AE%E3%81%82%E3%82%8B%E6%A3%AE%E3%82%92%E6%8A%9C%E3%81%91%E3%81%A6-%E6%A2%A8%E6%9C%A8-%E9%A6%99%E6%AD%A9/dp/4104299057","statistic":{"forked":"1","favorite":"2","pageview":"3547"},"url":"http://jsdo.it/crispy/iddX","user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"title":"侵食粘菌ライフゲーム forked from: CoffeeScript出来るかな"}