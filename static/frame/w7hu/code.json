{"source":{"css":"body { background-color: #fff; margin: 0px; overflow: hidden; }\n","html":"<canvas id='world'></canvas>","lisence":"MIT","js":"(function() {\n\tvar d = new DCore();\n\tvar mouse = new Mouse(d);\n\n    // カイルや冴子先生のようなもの(廃止)\n    /*\n\tfunction F1() {\n\t\tthis.phase = 0;\n\t\tthis.count = 0;\n\t}\n\n\tF1.prototype = {\n\t\tonInitial: function() {\n\t\t\tthis.phase = 0;\n\t\t\tthis.onPhaseChange();\n\t\t},\n\t\tonClickDot: function() {\n\t\t\tif(this.phase < 1) {\n\t\t\t\tthis.phase = 1;\n\t\t\t\tthis.onPhaseChange();\n\t\t\t}\n\t\t},\n\t\tonClickPad: function() {\n\t\t\tthis.phase = 2;\n\t\t\tthis.onPhaseChange();\n\t\t},\n\t\tonPhaseChange: function() {\n\t\t\tthis.count = 0;\n\t\t},\n\t\tact: function() {\n\t\t\tthis.count++;\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar texts = [\n\t\t\t\t\"> Click the any dot.\",\n\t\t\t\t\"> And Let's drag(or just click) pad!\",\n\t\t\t\t\"> That's all.\",\n\t\t\t];\n\n\t\t\tvar text = texts[this.phase];\n\n\t\t\tvar allLen = text.length;\n\t\t\tvar text = text.substr(0, this.count);\n\t\t\tvar display = true;\n\t\t\tif(this.count < allLen) {\n\t\t\t\t// add _ in displaying phase\n\t\t\t\ttext += \"_\";\n\t\t\t} else {\n\t\t\t\tvar past = this.count - text.length;\n\t\t\t\t// blink\n\t\t\t\tif(past < 16 && past % 8 < 4) {\n\t\t\t\t\tdisplay = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(display) {\n\t\t\t\td\n\t\t\t\t\t.rgb(0x99, 0x99, 0x99)\n\t\t\t\t\t.font(\"monospace\", 0.04, \"bold\")\n\t\t\t\t\t.fillText(text, [0.02, 0.02])\n\t\t\t\t\t.stroke()\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n    // シンセサイザークラス\n    // (どちらかというとミキサー)\n\tvar Synth = {\n        // 初期化処理\n\t\tinitialize: function() {\n\t\t\tthis.wg = new WaveGenerator();\n\t\t\tthis.wave = [];\n\t\t},\n        // 音を再生(やや汎用的)\n\t\tplaySlave: function(freq) {\n            // メモ化してなかった音データをつくる\n\t\t\tif(!this.wave[freq]) {\n\t\t\t\tvar envelove = function(x) {\n\t\t\t\t\tvar z = x * Math.PI * 2;\n\t\t\t\t\treturn Math.cos(z) * Math.cos(z);\n\t\t\t\t};\n\t\t\t\tthis.wave[freq] = this.wg.clean().sin(freq, 0.1, this.wg.flatdown).build();\n\t\t\t}\n            // 再生\n\t\t\tthis.wave[freq].stop();\n\t\t\tthis.wave[freq].play(0.2);\n\t\t},\n        // Ballクラスから呼び出される\n\t\tplayBall: function(ball) {\n            // ボールの位置から周波数を計算\n\t\t\tvar freqTn = ball.p[0] * 48;\n            // Webで検索 [平均律]\n\t\t\tvar magicNumber = Math.pow(Math.E, Math.log(2) / 12);\n            // 周波数\n\t\t\tvar freq = Math.pow(magicNumber, freqTn) * 220;\n\t\t\treturn this.playSlave(~~freq);\n\t\t},\n\t};\n\tSynth.initialize();\n\n\n    // ヘルパークラス。下記を束ねる\n    // -画面に並ぶ点(Dot)\n    // -オブジェクト(Pad)\n\tvar helper = {\n        // 初期状態\n\t\tPhaseInitial: 0,\n        // Dotがひとつ以上クリックされている\n\t\tPhaseDotClicked: 1,\n        // Padがクリックされている\n\t\tPhasePadClicked: 2,\n        // Padが離された\n\t\tPhasePadReleased: 3,\n\t\tphase: 0,\n\t\tinitialize: function() {\n\t\t\tthis.dotId = 0;\n\t\t\tthis.frame = 0;\n\t\t},\n        // DotIdを採番する\n        // ボールを具象化時に、ボールを生成する順番を決めるために使用する\n\t\tnumberingDotId: function() {\n\t\t\tthis.dotId++;\n\t\t\treturn this.dotId;\n\t\t},\n        // 引数(何フレームで頂点から床まで落とすか)から、\n        // 重力加速度、高さを算出する\n\t\tcalculateGravityAndHeight: function(frame) {\n\t\t\tvar g = 0.02 / frame * 1.05;\n\t\t\treturn [g, 1 - ((g * frame * (frame - 1) / 2) * 1.0) * 1.01];\n\t\t},\n        // Frames\n\t\tframes: [64, 32, 16, 8],\n        // Act\n\t\tact: function() {\n\t\t\tthis.frame++;\n\t\t\t// フェーズをコントロール\n            // \n\t\t\tif(this.phase === this.PhaseInitial) {\n                // 何かしらドットがおされたなら\n\t\t\t\tif(this.dots.flatten().any(function(x) { return x.active; })) {\n\t\t\t\t\tthis.phase = this.PhaseDotClicked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.phase === this.PhaseDotClicked) {\n                // ドットがすべてアンアクティブな状態\n\t\t\t\tif(!this.dots.flatten().any(function(x) { return x.active; })) {\n\t\t\t\t\tthis.phase = this.PhaseInitial;\n                // パッドがホバーされている、かつクリック状態\n\t\t\t\t} else if(this.pad.isHovered() && mouse.lbdowned) {\n\t\t\t\t\tthis.phase = this.PhasePadClicked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.phase === this.PhasePadClicked) {\n                // ボールを撒き散らせる\n\t\t\t\tif(this.pad.isReadyForScatter()) {\n\t\t\t\t\tthis.phase = this.PhasePadReleased;\n\t\t\t\t\tthis.pad.fadeOut();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.phase === this.PhasePadReleased) {\n                // パッドが終了時→初期状態へ\n\t\t\t\tif(this.pad.hasDeath()) {\n\t\t\t\t\tthis.phase = this.PhaseInitial;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.phase === this.PhaseInitial) {\n\t\t\t\tthis.pad.initialize();\n\t\t\t}\n\t\t\tif(this.phase === this.PhaseInitial\n\t\t\t|| this.phase === this.PhaseDotClicked) {\n\t\t\t\tthis.actDots();\n\t\t\t}\n\t\t\tif(this.phase >= this.PhaseDotClicked) {\n\t\t\t\t//kairuKun.onClickDot();\n\t\t\t\tthis.actPad();\n\t\t\t}\n\t\t\tif(this.phase >= this.PhasePadClicked) {\n\t\t\t}\n\t\t\tif(this.phase == this.PhasePadReleased) {\n\t\t\t\tthis.scatterBalls();\n\t\t\t\tthis.actPad();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tthis.drawDots();\n\t\t\tif(this.phase >= this.PhaseDotClicked) {\n\t\t\t\tthis.drawPad();\n\t\t\t}\n\t\t\tif(this.phase >= this.PhasePadClicked) {\n\t\t\t}\n\t\t},\n\t\tactDots: function() { \n\t\t\tthis.dots.flatMap(function(dot) {\n\t\t\t\tdot.act();\n\t\t\t});\n\t\t},\n\t\tdrawDots: function() {\n\t\t\tthis.dots.flatMap(function(dot) {\n\t\t\t\tdot.draw();\n\t\t\t});\n\t\t},\n\t\tactPad: function() {\n\t\t\tthis.pad.act();\n\t\t},\n\t\tdrawPad: function() {\n\t\t\tthis.pad.draw();\n\t\t},\n        // ボールを撒き散らすメソッド\n\t\tscatterBalls: function() {\n            // 撒き散らしの長さを特定(０～４を返す）\n\t\t\tvar str = ~~(this.pad.scatterStrength() / 16) / 8;\n            // 落下時が8フレームの倍数になるようにディレイをかける\n\t\t\tvar offset = 8 - this.frame % 8;\n            // 選択されているものを取得\n\t\t\tvar selected= this.dots.flatten().select(function(x) {\n\t\t\t\treturn x.active;\n\t\t\t});\n            // フレーム数の最大を取得\n\t\t\tvar maxFrame = selected.max(function(x) {\n\t\t\t\treturn x.frame;\n\t\t\t});\n            // dotId(選択された順番にソートして処理を行う)\n\t\t\tselected.sortBy(function(x) {\n\t\t\t\treturn x.dotId;\n\t\t\t}).zipWithIndex(function(x, i) {\n                // delay (dotId順序 * 撒き散らし速度 + オフセットディレイ)\n\t\t\t\tvar delay = i * str * maxFrame + (maxFrame - x.frame) + offset;\n                // 上記ディレイ分のフレーム数後にボールが追加されるように処理する\n\t\t\t\tli.add(function() {\n\t\t\t\t\tBallManager.add(new Ball(x.p[0], x.frame));\n\t\t\t\t}, delay);\n\t\t\t\tx.active = false;\n\t\t\t});\n\t\t},\n\t};\n\thelper.initialize();\n\n    // Dot(画面の点)\n\thelper.Dot = function(p, frame){\n\t\tthis.p = p;\n\t\tthis.frame = frame;\n\t\tthis.r = 0.02;\n\t\tthis.hoverSize = 0.018;\n\t\tthis.hoverCount = 0;\n\t\tthis.active = false;\n\t\tthis.hovered = false;\n\t\tthis.dotId = 0;\n\t};\n\thelper.Dot.prototype = {\n\t\tact: function(click) {\n\t\t\tif(this.isHovered()) {\n                // ホバー時、アニメーションの制御\n\t\t\t\tthis.hoverCount++;\n\t\t\t\tif(this.hoverCount < 6) {\n\t\t\t\t\tthis.r = Math.sin(this.hoverCount / 3 * Math.PI / 2) * 0.02 + 0.01;\n\t\t\t\t\tif(this.r < 0) this.r = 0.01;\n\t\t\t\t} else {\n\t\t\t\t\tthis.r = 0.03;\n\t\t\t\t}\n                // クリック時にアクティブ＜ー＞アンアクティブを制御\n\t\t\t\tif(mouse.lbdowned) {\n\t\t\t\t\tthis.dotId = helper.numberingDotId();\n\t\t\t\t\tthis.r *= 0.5;\n\t\t\t\t\tthis.active ^= true;\n\t\t\t\t}\n\t\t\t} else {\n                // ホバーされてない場合もアニメーション(しぼむ感じに)\n\t\t\t\tthis.hoverCount = 0;\n\t\t\t\tthis.r *= 0.8;\n\t\t\t\tif(this.r < 0.01) this.r = 0.01;\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar color = [0xcc, 0xcc, 0xcc];\n\t\t\tif(this.active) color = [0x00, 0x00, 0x00];\n\t\t\td\n\t\t\t .rgb(color)\n\t\t\t .circle(this.p, this.r)\n\t\t\t .fill()\n\t\t\t;\n\t\t},\n\t\tisHovered: function() {\n\t\t\treturn this.p.distance(mouse.p) < this.hoverSize;\n\t\t},\n\t\thandleClick: function() {\n\t\t},\n\t};\n\thelper.dots = function() {\n\t\treturn $R(0, 24).map(function(x) {\n\t\t\treturn helper.frames.map(function(f) {\n\t\t\t\tvar p = [x / 25 + 1 / 24 / 2, helper.calculateGravityAndHeight(f)[1]];\n\t\t\t\treturn new helper.Dot(p, f);\n\t\t\t})\n\t\t});\n\t}();\n\n\n    // Pad(画面中央に出てくる奴)\n\thelper.Pad = function() {\n\t\tthis.initialize();\n\t}\n\thelper.Pad.prototype = {\n\t\tinitialize: function() {\n\t\t\tthis.r = 0.0;\n\t\t\tthis.p = [0.5, 0.5];\n\t\t\tthis.count = 0;\n\t\t\tthis.hoverSize = 0.05;\n\t\t\tthis.clickCount = 0;\n\t\t\tthis.fadeOuting = false;\n\t\t},\n\t\tact: function() {\n\t\t\tthis.r *= 0.65;\n\t\t\tthis.r += 0.04;\n\t\t\tif(this.fadeOuting) {\n\t\t\t\tthis.fadeOutCount++;\n\t\t\t} else if(this.isHovered() && mouse.lbdown) {\n\t\t\t\tthis.clickCount++;\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar sc = this.clickCount % 16;\n\t\t\tvar c = [0x99, 0x99, 0x99];\n\t\t\tif(this.isHovered()) c = [0x00, 0x00, 0x00];\n\t\t\tif(this.fadeOuting) {\n\t\t\t\tvar a = this.fadeOutCount * 16;\n\t\t\t\tc = [a, a, a];\n\t\t\t\tthis.r *= 0.5;\n\t\t\t}\n\n\t\t\tthis.count++;\n\t\t\tif(sc === 0) {\n\t\t\t\tthis.r *= 0.9;\n\t\t\t}\n\t\t\td\n\t\t\t .rgb(c)\n\t\t\t .circle(this.p, this.r)\n\t\t\t .fill()\n\t\t\t;\n\n\t\t\tif(this.clickCount > 0) {\n\t\t\t\td\n\t\t\t\t .lineWidth(0.02)\n\t\t\t\t .rgb(0xff, 0xff, 0xff)\n\t\t\t\t .circle(this.p, this.r * 0.8, 0.0, Math.PI * 2 * this.clickCount / 64)\n\t\t\t\t .stroke()\n\t\t\t\t;\n\t\t\t}\n\t\t},\n\t\tisHovered: function() {\n\t\t\treturn this.p.distance(mouse.p) < this.hoverSize;\n\t\t},\n\t\tisReadyForScatter: function() {\n\t\t\treturn !this.isHovered() || !mouse.lbdown || this.clickCount >= 64;\n\t\t},\n\t\tfadeOut: function() {\n\t\t\tthis.fadeOuting = true;\n\t\t\tthis.fadeOutCount = 0;\n\t\t},\n\t\thasDeath: function() {\n\t\t\treturn this.fadeOuting && this.fadeOutCount > 16;\n\t\t},\n\t\tscatterStrength: function() {\n\t\t\treturn this.clickCount;\n\t\t},\n\t};\n\thelper.pad = new helper.Pad();\n\n\n\n    // Ball (弾んでる奴)\n\tfunction Ball(x, frame) {\n\t\tthis.p = [x, 0.1];\n\t\tvar work = helper.calculateGravityAndHeight(frame);\n\t\tthis.g = work[0];\n\t\tvar h = work[1];\n\t\tthis.p[1] = h;\n\t\tthis.sp = [0, this.g];\n\t\tthis.c = 1;\n\t\tthis.count = 0;\n\t}\n\tBall.prototype = {\n\t\tact: function() {\n\t\t\tthis.count++;\n\t\t\tthis.p = this.p.translate(this.sp);\n\t\t\tif(this.p[1] > 1) {\n\t\t\t\tthis.c = 1;\n\t\t\t\tthis.sp[1] *= -1;\n\t\t\t\tSynth.playBall(this);\n\t\t\t} else {\n\t\t\t\tthis.c++;\n\t\t\t\tthis.sp = this.sp.add([0, this.g]);\n\t\t\t}\n\t\t\t// FIXME ゴリ押し\n            // (落下からバウンド、初期位置に戻るまでのフレーム数が奇数フレームになってしまい、都合が悪いため\n            // 頂点に達した場合は1フレーム飛ばす)\n\t\t\tif(0 <= Math.abs(this.sp[1]) && Math.abs(this.sp[1]) <= this.g / 2) {\n\t\t\t\tthis.c--;\n\t\t\t\tthis.act();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\td\n\t\t\t .rgb(0x00, 0x00, 0x00)\n\t\t\t .circle(this.p, 0.01)\n\t\t\t .fill()\n\t\t\t;\n\t\t},\n\t\talive: function() {\n\t\t\treturn this.count < 1024;\n\t\t},\n\t};\n\n\tvar BallManager = {\n\t\tinitialize: function() {\n\t\t\tthis.balls = [];\n\t\t},\n\t\tact: function() {\n\t\t\tvar killed = this.balls.select(function(x) {\n\t\t\t\treturn !x.alive();\n\t\t\t});\n\t\t\tkilled.each(function(x) {\n\t\t\t\tEffectManager.add(new Effect(x.p));\n\t\t\t});\n\n\t\t\tthis.balls = this.balls.select(function(x) {\n\t\t\t\treturn x.alive();\n\t\t\t});\n\t\t\tthis.balls.each(function(ball) {\n\t\t\t\tball.act();\n\t\t\t});\n\t\t},\n\t\tdraw: function() {\n\t\t\tthis.balls.each(function(ball) {\n\t\t\t\tball.draw();\n\t\t\t});\n\t\t},\n\t\tadd: function(ball) {\n\t\t\tthis.balls.push(ball);\n\t\t},\n\t};\n\n\n\tfunction Effect(p) {\n\t\tthis.count = 0;\n\t\tthis.p = p.clone();\n\t}\n\tEffect.prototype = {\n\t\tact: function() {\n\t\t\tthis.count++;\n\t\t},\n\t\tdraw: function() {\n\t\t\tif(this.count > 7) return;\n\t\t\tvar a = this.count / 7;\n\t\t\ta *= a * 2;\n\t\t\tvar ar = 1 - a;\n\t\t\tvar s = 0.03;\n\t\t\td\n\t\t\t .lineWidth(ar * s / 1)\n\t\t\t .rgb(0x00, 0x00, 0x00)\n\t\t\t .circle(this.p, a * s + 0.01)\n\t\t\t .stroke()\n\t\t\t;\n\t\t},\n\t\talive: function() {\n\t\t\treturn this.count < 16;\n\t\t},\n\t};\n\n\tvar EffectManager = {\n\t\tinitialize: function() {\n\t\t\tthis.effects = [];\n\t\t},\n\t\tact: function() {\n\t\t\tthis.effects.each(function(ball) {\n\t\t\t\tball.act();\n\t\t\t});\n\t\t},\n\t\tdraw: function() {\n\t\t\tthis.effects.each(function(ball) {\n\t\t\t\tball.draw();\n\t\t\t});\n\t\t},\n\t\tadd: function(ball) {\n\t\t\tthis.effects.push(ball);\n\t\t},\n\t};\n\tEffectManager.initialize();\n\n    // LazyInvoke\n    // 時間差(フレーム単位)で関数を実行するクラス\n\tfunction LazyInvoker() {\n\t\tthis.task = [];\n\t}\n\tLazyInvoker.prototype = {\n        // 処理を追加\n        // func関数を、frameだけ遅れて実行する\n\t\tadd: function(func, frame) {\n\t\t\tthis.task.push([func, frame]);\n\t\t},\n        // キューに溜まった関数が指定のフレームに到達した場合実行する\n\t\tupdate: function() {\n\t\t\tthis.task.each(function(t) {\n\t\t\t\tif(t[1] <= 0) {\n\t\t\t\t\tt[0]();\n\t\t\t\t}\n\t\t\t\tt[1]--;\n\t\t\t});\n\n\t\t\tthis.task = this.task.select(function(t) {\n\t\t\t\treturn t[1] >= 0;\n\t\t\t});\n\t\t},\n\t};\n\n\tvar li = new LazyInvoker();\n\n\tBallManager.initialize();\n\n\t//var kairuKun = new F1();\n\n\n\tvar main = function() {\n\n\t\td\n\t\t .rgb(0xff, 0xff, 0xff)\n\t\t .fillBack()\n\t\t;\n\t\tmouse.flush();\n\n\t\thelper.act();\n\t\thelper.draw();\n\n\t\tBallManager.act();\n\t\tBallManager.draw();\n\n\t\tli.update();\n\n\t\tEffectManager.act();\n\t\tEffectManager.draw();\n\t\t//kairuKun.act();\n\t\t//kairuKun.draw();\n\t};\n\twindow.setInterval(main, 33);\n})();\n// vim:sw=2:ts=2"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/w/7/h/w7hu_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/w/7/h/w7hu.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/w/7/h/w7hu_100.jpg"},"description_html":"<p>ピコピコとアルベッジョできるシーケンサ</p>\n\n<p>♬</p>\n\n<ul>\n<li>ドットを複数選んで、出てきたオブジェを長押しする\n</li><li>ドットは縦が音符の長さ、横が音階\n</li><li>オブジェを押した長さに応じて、階段の早さが決定\n</li><li>アルベッジョじゃ無いです\n</li></ul>\n","parent":{"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/x/a/9/xa9f_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/x/a/9/xa9f.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/x/a/9/xa9f_100.jpg"},"modified_date":"2012-09-27 09:45:37","uid":"xa9f","created_date":"2012-09-26 17:21:03","path":"xa9f","description":"http://jsdo.it/event/q/2nd/vol3\r\n\r\nこのコードは、webクリエイターのためのコードコンテスト、Qのサンプルコードです。サイトからエントリーをし、こちらのコードをフォークしてください。\r\n\r\nお題：新しい楽器を作ってください\r\n---\r\n音楽の秋！ということで、HTML5、JavaScript、CSSを駆使してブラウザ上で動く楽器表現にチャレンジしてください。音の素材はお手本コードに含まれているので、音を自分なりに組み合わせ、同時に演出をつくってください。\r\n例えば、キーボードに反応して音が出るようなものや、絵を描いて音が出るようなもの、音の出る仕組みをアレンジしたものなど、音の素材は自分で用意してもよいので、自由な発想でチャレンジしてください。\r\n下記のお手本コードをFork（＝あなたなりのアレンジ）すると自動的にエントリーとなります。\r\n\r\n※コード内の音源は自由に使っていただいて構いません","statistic":{"forked":"59","favorite":"2","pageview":"31051"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/6/7/b/5/67b56e45ea501eedd27eec70435d26553c0eace6_100.jpg","name":"jsdo.it_team"},"url":"http://jsdo.it/jsdo.it_team/xa9f","title":"Web Creator's Contest Q the 2nd【vol.3】エントリー用コード"},"modified_date":"2012-10-14 21:50:38","uid":"w7hu","created_date":"2012-10-08 21:23:36","path":"w7hu","description":"<p>ピコピコとアルベッジョできるシーケンサ</p>\r\n\r\n♬\r\n<ul>\r\n<li>ドットを複数選んで、出てきたオブジェを長押しする\r\n<li>ドットは縦が音符の長さ、横が音階\r\n<li>オブジェを押した長さに応じて、階段の早さが決定\r\n<li>アルベッジョじゃ無いです\r\n</ul>\r\n","statistic":{"forked":"2","favorite":"6","pageview":"9649"},"url":"http://jsdo.it/crispy/w7hu","user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"title":"ping pong arpeggio"}