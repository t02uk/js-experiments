{"source":{"css":"body { background-color: #000000; margin: 0px; overflow: hidden; }\n","html":"<canvas id='world'></canvas>aaa","lisence":"MIT","js":"window.onload = function() {\n\n  var d = new DCore();\n  var color1 = [0xff, 0xff, 0xff];\n  var color2 = [0x00, 0x00, 0x00];\n\n\n  function Water() {\n    this.points = $R(0, 40).map(function(x) {\n      return {\n        pos:[x / 40, 0.5],\n        speed:[0, 0]\n      };\n    });\n  }\n  Water.prototype = {\n    act: function() {\n\n      var points = this.points;\n      var savedPoints = points.clone();\n\n      for(var i = 0, l = points.length; i < l; i++) {\n        var self = points[i];\n        if(i !== 0) {\n          var left = savedPoints[i - 1];\n        }\n        if(i !== l - 1) {\n          var right = savedPoints[i + 1];\n        }\n        if(left) {\n          self.speed[1] += (left.pos[1] - self.pos[1]) * 0.05;\n        }\n        if(right) {\n          self.speed[1] += (right.pos[1] - self.pos[1]) * 0.05;\n        }\n        self.speed[1] += (0.5 - self.pos[1]) * 0.06;\n        self.speed[1] *= 0.95;\n        self.pos[1] += self.speed[1];\n      }\n\n      this.ps = this.points.map(function(x){ return x.pos; });\n    },\n    draw: function() {\n      var ps = this.ps;\n      ps.push([1, 1], [0, 1]);\n      d\n        .rgb(color2)\n        .quads(\n          ps\n        )\n        .fill()\n      ;\n    },\n    isInBound: function(p) {\n      var ps = this.ps;\n      var offx = ~~(p[0] * (ps.length - 2));\n      if(offx >= ps.length - 2) offx = ps.length - 2;\n      if(offx <= 0) offx = 0;\n      var h = ps[offx  ][1]\n            + ps[offx+1][1] * (ps[offx][0] - p[0]);\n      return p[1] < h;\n    },\n    shock: function(p, power) {\n      var ps = this.ps;\n      var offx = ~~(p[0] * (ps.length - 2));\n      if(offx >= ps.length - 2) offx = ps.length - 2;\n      if(offx <= 0) offx = 0;\n      this.points[offx].pos[1] += (p[0] - ps[offx][0]) * ps.length * power;\n      this.points[offx].pos[1] +=-(p[0] - ps[offx+1][0]) * ps.length * power;\n    }\n  };\n\n\n  function Fish(sid) {\n    this.pos = [$R(0.0, 1.0).randf(), $R(0.1, 0.4).randf()];\n    this.speed = [$R(-0.01, 0.01).randf(), $R(0.01, -0.03).randf()];\n    this.visibleDist = $R(0.0, 0.15).randf();\n    this.sid = sid;\n    this.power = $R(0.01, 0.01).randf();\n\n    this.opos = new Array(5).fill([]);\n    this.count = 0;\n\n    this.inWater = false;\n  }\n  Fish.prototype = {\n    act: function() {\n      var self = this;\n      var fishes = god.fishes;\n      var visibleDist = this.visibleDist;\n      var direction = this.speed.normalize();\n      var intension = this.speed.mul(0.00000001);\n      \n      // 一番近い魚を探す\n      var nearestFish = fishes.sortBy(function(that) {\n        var square = self.pos.sub(that.pos).square();\n        if(self.sid === that.sid) return 10000;\n        else return square;\n      }).first();\n\n      // 範囲内の魚を求める\n      var visibleFishes = fishes.select(function(that) {\n        var square = self.pos.sub(that.pos).square();\n        if(self.sid === that.sid) return false;\n        if(square >= visibleDist * visibleDist) return false;\n        if(self.speed.dot(that.pos.sub(self.pos) < -0.5)) return false;\n        return true;\n      });\n\n      // 引き離し\n      var realDist = self.pos.sub(nearestFish.pos).abs();\n      // 理想距離\n      var idealDist = 0.1;\n      if(realDist < idealDist * 2) {\n        var intension1 = (realDist - idealDist) / idealDist * 1.0;\n        intension = intension.add(nearestFish.pos.sub(self.pos)).mul(intension1);\n      }\n\n      // 整列\n      if(visibleFishes.length) {\n        // 可視範囲の魚の向きを算出\n        var intension2 = visibleFishes.inject([0, 0], function(i, e) {\n          return i.add(e.speed.normalize());\n        }).normalize();\n        intension = intension.add(intension2.mul(0.003));\n      }\n\n      // 結合\n      if(visibleFishes.length) {\n        // 可視範囲の中心座標を算出\n        var center = visibleFishes.inject([0, 0], function(i, e) {\n          return i.add(e.pos);\n        }).mul(1 / visibleFishes.length);\n        var intension3 = center.sub(self.pos).normalize();\n        intension = intension.add(intension3.mul(0.015));\n      }\n\n      this.power += 0.0008;\n\n\n      // 速度制御\n      var oldInWater = this.inWater;\n      this.inWater = water.isInBound(this.pos);\n\n      // マウスを避ける\n      if(!this.inWater && [px, py].sub(self.pos).abs() < 0.1) {\n        intension = self.pos.sub([px, py]);\n        this.power += 0.01;\n      }\n\n      if(this.inWater) {\n        // 水中の時\n        this.speed = this.speed.add([0, 0.003]);\n        this.power *= 0.99;\n      } else {\n        intension = intension.rotate((Math.sin(self.count / 1.5) / 16).toRadian());\n        this.speed = this.speed.add(intension.normalize(0.005));\n        this.speed = this.speed.normalize(this.power);\n        this.power *= 0.90;\n      }\n      if(oldInWater != this.inWater) {\n        water.shock(this.pos, this.speed.dot([0, 1.3]));\n      }\n\n      // 壁判定\n      this.pos = this.pos.add(this.speed);\n      if(!(0.0 <= this.pos[0] && this.pos[0] <= 1.0)) {\n        this.speed[0] = -this.speed[0];\n        this.pos[0] = [0, this.pos[0], 1].sort()[1];\n      }\n      if(!(0.0 <= this.pos[1] && this.pos[1] <= 1.0)) {\n        this.speed[1] = -this.speed[1];\n        this.pos[1] = [0, this.pos[1], 1].sort()[1];\n      }\n\n      // 履歴へプッシュ\n      this.opos.push(this.pos);\n      this.opos.shift();\n\n      this.count++;\n    },\n    draw: function() {\n\n      d\n       .rgb(water.isInBound(this.pos) ? color2 : color1)\n       .quads(this.opos)\n       .fill()\n       .stroke()\n      ;\n    }\n  };\n\n  function God() {\n    this.fishes = $R(0, 16).map(function(x) {\n      var fish = new Fish(x);\n      return fish;\n    });\n  }\n  God.prototype = {\n    act: function() {\n      this.fishes.invoke(\"act\");\n    },\n    draw: function() {\n      this.fishes.invoke(\"draw\");\n    }\n  };\n  var god = new God();\n\n\n  var water = new Water();\n\n  (1).times(function() {\n    water.act();\n    god.act();\n  });\n\n\n  var px, py;\n  (function() {\n    window.addEventListener(\"mousemove\", function(e) {\n      px = e.clientX / d.width - d.left2d;\n      py = e.clientY / d.height - d.top2d;\n    }, false);\n    god.act();\n\n    window.setInterval(function() {\n      d\n       .rgb(color1)\n       .fillBack()\n      ;\n\n      water.act();\n      god.act();\n\n      water.draw();\n      god.draw();\n    }, 33);\n  })();\n\n};\n// vim:sw=2:ts=2\n\n"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/h/C/x/hCxz_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/h/C/x/hCxz.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/h/C/x/hCxz_100.jpg"},"description_html":"おさかなシミュレータ<br />\nandroid version (LiveWallpaper) :<a  href=\"https://play.google.com/store/apps/details?id=com.twitter.t02uk.sea\">https://play.google.com/store/apps/details?id=com.twitter.t02uk.sea</a>","modified_date":"2012-04-20 23:22:10","uid":"hCxz","created_date":"2010-12-30 23:08:55","path":"hCxz","description":"おさかなシミュレータ\nandroid version (LiveWallpaper) :https://play.google.com/store/apps/details?id=com.twitter.t02uk.sea","statistic":{"forked":"19","favorite":"62","pageview":"23591"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"url":"http://jsdo.it/crispy/hCxz","title":"monochrome aquariumu"}