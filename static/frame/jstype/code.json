{"source":{"css":"body { background-color: #ffffff; margin: 0px; overflow: hidden; }","html":"<canvas id='world'></canvas>","lisence":"MIT","js":"window.onload = function() {\n\n  // ;d\n  var d = new DCore();\n  var random = function() {\n    var x = 1;\n    return function() {\n      x = (x * 22695477 + 1) & 0xffffffff;\n      return ((x >> 16) & 0x7fff) / 0x7fff;\n    };\n  };\n\n  // {{{ タイピングフェーズ\n  function OnTyping() {\n\n    this.startTime = +new Date() - 0 * 59500;\n    this.timeupdCnt = 0;\n\n    var problems = $R(0, 500, true).map(function(e) {\n      return Global.methods[Global.methods.length.rand()];\n    });\n\n    // {{{ パーティクルエフェクト\n    function Particle(p, s) {\n      this.p = p;\n      this.s = s;\n      this.hue = $R(0, 1).randf();\n    }\n    Particle.prototype = {\n      act: function() {\n        this.p = this.p.add(this.s);\n        this.s = this.s.mul(0.9);\n      },\n      draw: function() {\n        d\n         .blend(\"source-over\")\n         .alpha(this.s.abs() * 30)\n         .hsv(this.hue, 0.3, 0.9)\n         .circle(this.p, 0.01)\n         .fill()\n        ;\n      }\n    };\n    // }}}\n\n\n    // {{{ 問題描画用\n    function ProblemLabel(problem) {\n      this.problem = problem;\n      this.numTyped = 0;\n      this.font = [\"monospace\", 0.04, \"bold\"];\n      this.r = (d.font(this.font).measureText(problem)) * 1.2 + 0.05;\n      this.shakePower = 0;\n      this.completed = false;\n      this.hue = $R(0, 1).randf();\n\n      this.repNumTyped = 0;\n      this.repCompleted = false;\n      this.missTyped = false;\n    }\n    ProblemLabel.prototype = {\n      activate: function() {\n        this.active = true;\n      },\n      isInBound: function(that) {\n        var f = this.p.distance(that.p) < this.r + that.r;\n        return f;\n      },\n      handleTyped: function(key) {\n        var expected = this.problem.charCodeAt(this.numTyped);\n        if(key === 0) return null;\n\n        var correct = expected == key;\n        this.missTyped = !correct;\n        if(correct) {\n          this.numTyped++;\n          this.shakePower += 0.3;\n          if(this.numTyped >= this.problem.length) {\n            this.completed = true;\n          }\n        } else {\n        }\n\n        return correct;\n      },\n      repTyped: function(key) {\n        this.repNumTyped++;\n        if(this.repNumTyped >= this.problem.length) {\n          this.repCompleted = true;\n        }\n      },\n      act: function() {\n        this.shakePower *= 0.5;\n      },\n      draw: function(rep) {\n\n        if(rep) {\n          if(this.repNumTyped) {\n            d\n              .blend(\"source-over\")\n              .alpha(0.8)\n              .hsv(0.0, 0.2, 0.95)\n              .circle(this.p, this.r * (1 + this.shakePower) + 0.03 + 0.03, (0).toRadian(), (this.repNumTyped / this.problem.length).toRadian())\n              .stroke()\n              ;\n          }\n        } else {\n          if(this.active) {\n\n            d\n              .blend(\"source-over\")\n              .alpha(1)\n              .hsv(this.missTyped ? [0, 0.7, 0.85] : [this.hue, 0.3, 0.85])\n              .circle(this.p, this.r * (1 + this.shakePower))\n              .fill()\n              ;\n\n            if(this.numTyped) {\n              d\n                .blend(\"source-over\")\n                .alpha(1)\n                .hsv(0.6, 0.3, 0.95)\n                .circle(this.p, this.r * (1 + this.shakePower) + 0.03, (0).toRadian(), (this.numTyped / this.problem.length).toRadian())\n                .stroke()\n                ;\n            }\n\n            d\n              .font(this.font)\n              .hsv(this.hue, 0.3, 0.3)\n              .textAlign(\"center\")\n              .textBaseline(\"middle\")\n              .fillText(this.problem, this.p)\n              ;\n\n            var typed = this.problem.substr(0, this.numTyped);\n\n            d\n              .font(this.font)\n              .rgb(0xff, 0xff, 0xff)\n              .textAlign(\"center\")\n              .textBaseline(\"middle\")\n              .fillText(typed, this.p.add([-d.font(this.font).measureText(this.problem.substr(this.numTyped)) * 0.5, 0]))\n          } else {\n            d\n              .blend(\"source-over\")\n              .alpha(1)\n              .hsv(this.hue, 0.1, 0.95)\n              .circle(this.p, this.r)\n              .stroke()\n              .fill()\n              ;\n\n            d\n              .font(this.font)\n              .rgb(0x99, 0x99, 0x99)\n              .textAlign(\"center\")\n              .textBaseline(\"middle\")\n              .fillText(this.problem, this.p)\n              ;\n          }\n        }\n        return\n      },\n    }\n    // }}}\n\n    // 全体描画制御\n    function TypeField(problems, ki, replay) {\n      this.numSolved = 0;\n      this.problems = problems;\n      this.ki = ki;\n      this.pls = [];\n      this.allPls \n      this.plsIdx = 0;\n      this.plsCapacity = 5;\n      this.particles = [];\n      this.numAllocated = 0;\n      this.cameraP = [0, 0];\n      this.score = 0;\n      this.ir = new InputRecorder(ki);\n      this.replay = replay;\n      this.replay.reset();\n\n      this.repIdx = 0;\n\n      this.wholePls = [];\n\n\n      var self = this;\n      var c = 0;\n      var _ = function(m) {\n        var pls = self.wholePls;\n        while(pls.length < m) {\n          var i = 0;\n          var problem = self.problems[pls.length];\n          var pl = new ProblemLabel(problem);\n          do {\n            pl.p = [$R(0.15, 0.85).randf(), c * 0.2 + $R(0, 0.1).randf() + 0.2];\n            if(i++ > 100) break;\n          } while(pls.all(function(that) { return !pl.isInBound(that); }) && pls.length !== 0)\n          pls.push(pl);\n          c++;\n\n          if(i++ > 100) break;\n        }\n      }\n\n      _(10);\n      for(i = 1; i < 30; i++) {\n        window.setTimeout(_.curry(10 * i), 1000 * i);\n      }\n\n      this.allocate();\n\n      this.repPl = this.wholePls[0];\n    }\n    TypeField.prototype = {\n      allocate: function() {\n        var pls = this.pls;\n\n        while(pls.length < this.plsCapacity) {\n          pls.push(this.wholePls[this.numAllocated]);\n          this.numAllocated++;\n        }\n\n        pls[0].activate();\n\n      },\n      act: function() {\n\n        // key control\n        var key = this.ki.get();\n\n        var f = this.pls[0].handleTyped(key);\n        if(f) {\n          this.ir.record();\n        }\n\n        if(f !== null) {\n          this.score += f ? 61 : 81;\n        }\n\n\n        if(this.pls[0].completed) {\n          var self = this;\n\n          $R(0, 16, true).each(function(i) {\n            self.particles.push(\n              new Particle(self.pls[0].p, [0, $R(0.02, 0.04).randf()].rotate((i / 16).toRadian()))\n            );\n          });\n\n          this.pls.shift();\n        }\n\n        // Replay\n        var f = replay.next();\n        if(f) {\n          console.log(\"!\");\n          this.repPl.repTyped();\n          if(this.repPl.repCompleted) {\n            console.log(\"c\");\n            this.repPl = this.wholePls[++this.repIdx];\n          }\n        }\n\n\n        this.allocate();\n        this.pls.invoke(\"act\");\n\n        this.particles = this.particles.select(function(e) {\n          return e.s.square() > 0.00001;\n        });\n        this.particles.invoke(\"act\");\n\n        var y = this.pls[0].p[1];\n        this.cameraP = [0, (this.cameraP[1] * 9 + y) / 10];\n\n        return this;\n      },\n      draw: function() {\n        var self = this;\n\n        // background pattern\n        $R(0, 10).each(function(i) {\n          var y = i / 10 + (100000 - self.cameraP[1]);\n          y %= 1;\n          d\n           .rgb(0xee, 0xee, 0x99 + self.cameraP[1] * 5)\n           .line([\n             [0, y],\n             [1, y]\n            ])\n           .stroke()\n          ;\n        });\n\n\n        // objects\n        d.top2d = -this.cameraP[1] + 0.2;\n\n        this.repPl.draw(true);\n        this.particles.invoke(\"draw\");\n        this.pls.reverse().invoke(\"draw\");\n        this.pls.reverse();\n\n\n        d.top2d = 0;\n\n      }\n    };\n    // }}}\n\n    replay.decode(Global.replay);\n    this.tfs = $R(1, 1).map(function(e) { return new TypeField(problems, ki, replay); });\n  }\n  OnTyping.prototype = {\n    act: function() {\n      if(this.timeupdCnt) return this;\n      this.tfs.invoke(\"act\");\n      return this;\n    },\n    draw: function() {\n      var tfs = this.tfs;\n\n      // fill back\n      d\n       .blend(\"source-over\")\n       .alpha(1)\n       .rgb(0xff, 0xfc, 0xf3)\n       .fillBack()\n      ;\n\n      tfs.invoke(\"draw\");\n\n      // time information\n      var remain = new Date() - this.startTime;\n      var remain_ms = ~~((remain % 1000) / 100);\n      var remain_s = ~~(remain / 1000);\n\n      if(remain_s >= 60) {\n        this.timeupdCnt++;\n        var c = this.timeupdCnt;\n\n        // background pattern\n        $R(0, 10).each(function(i) {\n          var x = i / 10;\n          d\n           .rgb(0xff, 0xff, 0xff)\n           .quads([\n             [x, 0],\n             [x + c / 200, 0],\n             [x + c / 200, 1],\n             [x, 1],\n            ])\n           .fill()\n          ;\n        });\n\n        return this;\n      }\n\n      d\n        .blend(\"source-over\")\n        .alpha(0.8)\n        .circle([0.9, 0.9], 0.2)\n        .rgb(0xee, 0xd9, 0x99)\n        .fill()\n        .lineWidth(0.015)\n        .rgb(0xcc, 0x66, 0x66)\n        .circle([0.9, 0.9], 0.18, (0.75).toRadian(), (remain_s / 60 + 0.75).toRadian())\n        .stroke()\n        .rgb(0x66, 0xcc, 0x66)\n        .lineWidth(0.015)\n        .circle([0.9, 0.9], 0.2, (-0.25).toRadian(), (remain_ms / 10 - 0.25).toRadian())\n        .stroke()\n      ;\n\n      d\n        .rgb(0x97, 0x82, 0x42)\n        .font(\"monospace\", 0.06, \"bold\")\n        .textAlign(\"center\")\n        .textBaseline(\"middle\")\n        .fillText(remain_s + \".\" + remain_ms, [0.9, 0.9])\n      ;\n\n      return this;\n    },\n    next: function() {\n      if(this.timeupdCnt > 20) {\n        return new OnTitle(this.tfs[0].score, this.tfs[0].ir.encode());\n      }\n      else return this;\n    },\n  }\n  // }}}\n\n  // OnTitle\n  function OnTitle(score, replay) {\n    this._next = this;\n    this.score = score;\n    this.replay = replay;\n  }\n  OnTitle.prototype = {\n    act: function() {\n      var key = ki.next();\n      if(key == \"s\".charCodeAt(0)) this._next = new OnTyping();\n      if(key == \"t\".charCodeAt(0)) tweet(this.replay);\n    },\n    draw: function() {\n\n      d\n       .rgb(0xff, 0xff, 0xff)\n       .fillBack()\n      ;\n\n      var rnd = random();\n      (25).times(function(i) {\n        var p = [\n          rnd(), rnd()\n        ]\n        var r = rnd() / 20 + 0.03;\n        var hue = rnd();\n\n        d\n         .hsv(hue, 0.05, 0.95)\n         .circle(p, r)\n         .fill()\n        ;\n      });\n\n\n      \"JS*TYPE\".split(\"\").zipWithIndex(function(e, i) {\n        var p = [i * 0.1 + 0.2, 0.4];\n        d\n         .hsv(i / 7, 0.4, 0.9)\n         .circle(p, 0.1)\n         .fill()\n         .textAlign(\"center\")\n         .textBaseline(\"middle\")\n         .font(\"monospace\", 0.08, \"bold\")\n         .hsv(i / 7, 0.0, 1.0)\n         .fillText(e, p)\n        ;\n      });\n\n\n      d\n       .rgb(0xff, 0x66, 0x99)\n       .font(\"monospace\", 0.05, \"bold\")\n       .textAlign(\"left\")\n       .fillText(\"Score: \" + (this.score ? this.score : \"0\"), [0.2, 0.6])\n       .fillText(\"* Press 'S' Key To Play\", [0.2, 0.7])\n       .fillText(this.replay ? \"* Or, Press 'T' Key To Tweet Replay\" : \"\", [0.2, 0.8])\n      ;\n    },\n    next: function() {\n      return this._next;\n    },\n  }\n\n  // {{{ 共通グローバル領域\n  var Global = {};\n  // {{{ メソッド一覧取得\n  Global.methods = (function(objs) {\n    var results = [];\n    [objs].each(function(obj) {\n      for(var i in obj) {\n        if((obj.hasOwnProperty(i) \n        || (obj.prototype && obj.prototype.hasOwnProperty(i)))\n        && (obj[i] instanceof Function)\n\t&& (!i.match(/[^a-zA-Z]/))) {\n          results.push(i);\n        }\n      }\n    });\n    return results.uniq();\n  })(jQuery, jQuery.fn);\n  // }}}\n  // {{{ リプレイ\n  Global.replay = (function(p) {\n    var post = p.split(\"?\");\n    if(post.length < 2) return \"\";\n    var hash = post[1];\n    var h = (function(hash) {\n      return hash.split(\"&\").map(function(x) {\n        return x.split(\"=\");\n      });\n    })(hash);\n    var hs = {};\n    for(var i = 0; i < h.length; i++) {\n      hs[h[i][0]] = h[i][1];\n    }\n    return hs[\"replay\"] || \"\";\n  })(location.search);\n  // }}}\n  // }}}\n\t\n  // {{{ キーボード入力ハンドラ\n  function KeyInput() {\n    var self = this;\n    self.key = 0;\n    window.addEventListener(\"keydown\", function(e) {\n      if('A'.charCodeAt(0) <= e.keyCode && e.keyCode <= 'Z'.charCodeAt(0)) {\n        self.key = e.keyCode ^ !e.shiftKey << 5;\n      }\n    }, false);\n  }\n  // }}}\n  // {{{ prototype\n  KeyInput.prototype = {\n    get: function() {\n      return this.key;\n    },\n    next: function() {\n      var a = this.key\n      this.key = 0;\n      return a;\n    }\n  };\n  // }}}\n  var ki = new KeyInput();\n\n\n  // {{{ デバイス入力レコーダ/簡易録画、再生機能機能\n  function InputRecorder(recordee) {\n    this.clear();\n    var self = this;\n    this.startTime = +new Date();\n    this.playCount = 0;\n\n    // アスペクトでフック -> 無理\n    //var recordee_next = recordee.next;\n    //recordee.next = function() {\n    //  var a = recordee_next.call(recordee);\n    //  if(a) {\n    //    self.inputs.push({\"key\": a, \"time\": ~~(new Date() - startTime) / 16});\n    //  }\n    //  return a;\n    //};\n\n    this.recordee = recordee;\n\n    this.convTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  }\n  // }}}\n  // {{{ prototype\n  InputRecorder.prototype = {\n    clear: function() {\n      this.inputs = [];\n      this.playCount = 0;\n    },\n    reset: function() {\n      this.startTime = +new Date();\n    },\n    get: function() {\n      return this.inputs[0];\n    },\n    record: function() {\n      this.inputs.push({\n        \"time\": ~~(new Date() - this.startTime) / 16\n      });\n    },\n    next: function() {\n      if(!this.inputs.length) return;\n      if(this.inputs.length <= this.playCount) return;\n\n      var d = ~~(new Date() - this.startTime) / 16;\n      if(d >= this.inputs[this.playCount].time) {\n        this.inputs[this.playCount];\n        this.playCount++;\n        return true;\n      }\n      return false;\n    },\n    encode: function() {\n      var inputs = this.inputs;\n      var result = \"\";\n      for(i = 0, l = inputs.length; i < l; i++) {\n        var input = inputs[i];\n        var d = inputs[i].time - (i ? inputs[i - 1].time : 0);\n        var dh = d >> 6;\n        var dl = d & 63;\n        result += this.convTable.substr(dh, 1) + this.convTable.substr(dl, 1);\n      }\n      return result;\n    },\n    decode: function(raw) {\n      this.clear();\n      var ot = 0;\n      for(i = 0, l = raw.length; i < l; i += 2) {\n        var d = raw.substring(i, i + 2);\n        var dh = this.convTable.indexOf(d.substr(0, 1));\n        var dl = this.convTable.indexOf(d.substr(1, 1));\n        var t = dh << 6 | dl & 63;\n        ot += t\n        this.inputs.push({\"time\": ot});\n      }\n    },\n  };\n  // }}}\n  var replay = new InputRecorder();\n\n  function tweet(replay) {\n    window.callback = function(bitlyResponse) {\n      shortUrl = bitlyResponse.results[url].shortUrl;\n      window.open(\"http://twitter.com/share?url=\"+url, 'tweet', 'width=550, height=450,personalbar=0,toolbar=0,scrollbars=1,resizable=1');\n    }\n    var url = \"http://jsrun.it/t02uk/jstype\" + \"?\" + \"replay=\" + replay;\n    var login  = 'o_7t5r7knc2s';\n    var apiKey = 'R_7a210c6e5993a8c6e59c6dded03e55c4';\n    bitly = 'http://api.bit.ly/shorten' \n        + '?version=2.0.1&format=json&callback=callback'\n        + '&login=' + login\n        + '&apiKey=' + apiKey\n        + '&longUrl=' + url;\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = bitly;\n    document.body.appendChild(script);\n  }\n  \n  /// {{{ メイン\n  (function(phase) {\n    phase.act();\n    phase.draw();\n\n    ki.next();\n\n    window.setTimeout(arguments.callee.curry(phase.next()), 33);\n  })(new OnTitle());\n  /// }}}\n\n};\n\n// vim:sw=2:ts=2:foldmethod=marker:\n"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/1/V/P/1VPC_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/1/V/P/1VPC.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/1/V/P/1VPC_100.jpg"},"description_html":"ツイッターでリプレイ投稿するタイピングゲーム試作。<br />\n<br />\n(追記)　新しめのブラウザで画面まっくろになるの修正","modified_date":"2012-04-20 23:12:17","uid":"1VPC","created_date":"2011-08-13 18:45:14","path":"jstype","description":"ツイッターでリプレイ投稿するタイピングゲーム試作。\n\n(追記)　新しめのブラウザで画面まっくろになるの修正","statistic":{"forked":"5","favorite":"13","pageview":"8234"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"url":"http://jsdo.it/crispy/jstype","title":"JS*TYPE"}