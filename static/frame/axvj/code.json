{"source":{"css":"body { background-color: #000000; margin: 0px; overflow: hidden; }","html":"<canvas id='world'></canvas>","lisence":"MIT","js":"window.onload = function() {\n\n  var d = new DCore();\n\n  // hh:mm:ss\n  var hh_mm_ss = function(date) {\n    // 先頭ゼロ埋め\n    var foo = function(s) { return (\"0\" + s).substr(-2, 2); };\n    var ret = foo(date.getHours()) + \":\" + foo(date.getMinutes()) + \":\" + foo(date.getSeconds());\n    return ret;\n  };\n\n  // 文字の形状を形成/管理する\n  function Letter(content) {\n\n    // 大きさ\n    var s = 0.05;\n\n    // 背景塗って、指定の文字を描画\n    d\n     .rgb(0x00, 0x00, 0x00)\n     .rect([0.0, 0.0], [s, s])\n     .fill()\n     .font(\"monospace\", s)\n     .rgb(0xff, 0xff, 0xff)\n     .fillText(content, [0, 0])\n    ;\n\n    // ピクセルデータの取得\n    var img = d.getImageData([0, 0], [s, s]);\n    var mm = [];\n\n    // 描画した文字を解析\n    var m = $R(0, img.width, true).map(function(y) {\n      return $R(0, img.height, true).map(function(x) {\n        var r = img.at([x / img.width, y / img.height])[0];\n        if(r > 0x80) mm.push([x / img.width, 1 - y / img.height]);\n        return r > 0x80;\n      });\n    });\n\n    // 形状データ(該当座標か否かを格納する)\n    this.m = m;\n\n    // 形状データ(該当座標を格納する)\n    this.mm = mm;\n  }\n\n  // 文字を作成\n  var letters = {};\n  \"0123456789:\".split(\"\").each(function(e) {\n    letters[e] = new Letter(e);\n  });\n\n\n  // 粒子\n  function Particle(p) {\n    this.p = p;\n    this.s = 0.05;\n    this.hue = 0.6;\n    this.assigned = false;\n  }\n  Particle.prototype = {\n    act: function() {\n    },\n    // アニメーション用の関数を更新\n    updateAnimator: function(a) {\n      this.animator = a;\n    },\n    // アニメーション用の関数を適用\n    move: function(t) {\n      if(this.animator) this.p = this.animator(t);\n    },\n    draw: function() {\n      if(Camera.p.distance(this.p) < 1.5) return;\n      var s = this.s;\n      var h = this.hue;\n      d\n        .blend(\"lighter\")\n        .alpha(1.0)\n        .luminous(this.p, s / 4, s, [\n          [0.1,   [h, 0.2, 1.0].hsv()],\n          [0.6,   [h, 0.4, 0.3].hsv()],\n          [0.7,   [h, 0.2, 0.2].hsv()],\n          [1.0,   [h, 0.0, 0.0].hsv()],\n        ])\n        .fill()\n      ;\n    }\n  };\n\n\n  // カメラ\n  Camera = {\n    updateAnimator: function(pa, ua) {\n      this.pAnimator = pa;\n      this.uAnimator = ua;\n    },\n    move: function(t) {\n      if(this.pAnimator) this.p = this.pAnimator(t);\n      if(this.uAnimator) this.u = this.uAnimator(t);\n    },\n    act: function() {\n      d\n       .gazeFrom(Camera.p, Camera.g, Camera.u);\n    },\n  };\n  Camera.p = [0, 0, -4];\n  Camera.u = [0, 1,  0];\n\n\n  // 初期パーティクルを生成\n  var particles = $R(0, 180).map(function(e) {\n    var r = 2;\n    var rr = function(){return $R(-r, r).randf();};\n    return new Particle([rr(), rr(), rr()]);\n  });\n\n\n  // べじェ・・・\n  var bezier = function(p1, p2, p3, p4) {\n    return function(t) {\n      var u = 1 - t;\n      return p1.mul(u * u * u)\n        .add(p2.mul(u * u * t * 3))\n         .add(p3.mul(u * t * t * 3))\n          .add(p4.mul(t * t * t));\n    };\n  };\n\n  // 前回ループ時の秒を保持\n  var olds = new Date().getSeconds();\n  (function(c) {\n\n    // 時刻取得\n    var date = new Date();\n    var h = date.getHours();\n    var m = date.getMinutes();\n    var s = date.getSeconds();\n    var ms = date.getMilliseconds();\n\n\n    // 秒が変わった瞬間\n    if(s != olds) {\n\n      // 回転角度を設定\n      var rad1 = $R(-0.25, 0.25).randf().toRadian();\n      var rad2 = $R(-0.25, 0.25).randf().toRadian();\n      var rad3 = $R(-0.2, 0.2).randf().toRadian();\n\n      // カメラがこれから向く方向を設定(ポジション、頭の向き)\n      var p = [0, 0, -4].rotatex(rad1).rotatey(rad2);\n      var u = [0, 1, 0].rotatea(rad3, p.normalize());\n\n      // 目的と、現在地との中間地点の座標を算出\n      var pcenter = p.add(Camera.p).mul(0.5);\n      var ucenter = u.add(Camera.u).mul(0.5);\n\n      // 三次元乱数生成関数\n      var rp = function(r){return $R(r, r).randf();}.curry(0.1);\n      var ru = function(r){return $R(r, r).randf();}.curry(0.3);\n\n      // アニメーション関数を適用\n      Camera.updateAnimator(\n         bezier(Camera.p.clone(), pcenter.add([rp(), rp(), rp()]), pcenter.add([rp(), rp(), rp()]), p.clone()),\n         bezier(Camera.u.clone(), ucenter.add([ru(), ru(), ru()]), ucenter.add([ru(), ru(), ru()]), u.clone())\n      );\n\n      // (カメラの注視点)からカメラに対してのベクトル\n      var hoge = p.normalize(1);\n\n      // パーティクル\n      var pp = particles.clone();\n\n      // hh:mm:ssに変換後の文字形状を取得する\n      var a = hh_mm_ss(date).split(\"\");\n      a = a.zipWithIndex(function(e, i) {\n        return letters[e].mm.translate([0.25 * i - 1.0, 0]);\n      }).shallowFlatten();\n\n      // 文字盤にパーティクルを割り当てる\n      // 準備\n      var rr = function(r){return $R(-r, r).randf();}.curry(0.5);\n      var r3 = [rr(), rr(), rr()];\n\n      // ここから割り当て\n      a.each(function(e) {\n        // z = 凹み具合\n        var z = $R(-0.5, 0.5).randf();\n        var k = 0.3 * (z + 4);\n        var p = [e[0] * k, (e[1] - 0.5) * k, z].rotatex(rad1).rotatey(rad2);\n        p = p.rotatea(rad3, hoge);\n        var par = pp.pop();\n        var p2 = par.p.add(r3).add([rr(), rr(), rr()].mul(1.0));\n        var p3 = p2.add([rr(), rr(), rr()].mul(1.0));\n        par.updateAnimator(bezier(par.p, p2, p3, p));\n        par.assigned = true;\n      });\n\n      // 余ったパーティションをばらまく\n      pp.select(\n        function(e) { return e.assigned; }\n      ).each(function(e) {\n        var rr2 = function(r){return $R(-r, r).randf();}.curry(2.5);\n        var p4 = [rr2(), rr2(), rr2()];\n        var rr = function(r){return $R(-r, r).randf();}.curry(0.3);\n        e.updateAnimator(bezier(e.p, e.p.add([rr(), rr(), rr()]), p4.add([rr(), rr(), rr()]), p4));\n        e.assigned = false;\n      });\n\n      // 色変え\n      if(s === 0) {\n        particles.each(function(e) {\n          e.hue = (m / 6) % 1;\n        });\n      }\n      \n    }\n    \n       \n    // 背景を初期化\n    d\n     .blend(\"source-over\")\n     .alpha(1.0)\n    .rgb((olds !== s && s === 0) ? [0x66, 0x66, 0x66] : [0x00, 0x00, 0x00])\n     .fillBack();\n\n\n    // アニメーションメモ\n    //   100ms 200ms 300ms 400ms 500ms 600ms 700ms 800ms 900ms\n    //   ←パーティクル     →\n    //                           ←カメラ              →\n    //\n\n    // カメラ\n    if(ms < 500) {}\n    else if(500 < ms && ms < 900) Camera.move((ms - 500) / 400);\n    else Camera.move(1);\n    Camera.act(1);\n\n    // パーティクル\n    if(ms < 400) particles.invoke(\"move\", ms / 400);\n    else particles.invoke(\"move\", 1);\n    particles.invoke(\"act\");\n    particles.invoke(\"draw\");\n\n\n    // 右下のプレビュー部分を描く\n    //\n    d\n      .save()\n      .translate([0.35, 0.35])\n      .quads(Geo.rect().translate([0.4, 0.4]), true)\n      .clip()\n      .save()\n    ;\n\n    // プレビュー用に座標系を変更\n    d\n     .blend(\"source-over\")\n     .alpha(1.0)\n     .rgb(0x00, 0x00, 0x00)\n     .fillBack()\n     .rgb(0xff, 0xff, 0xff)\n     .quads(Geo.rect().translate([0.4021, 0.402]))\n     .stroke()\n     .gazeFrom([10, 10, 10], [0, 0, 0], [0, 1, 0])\n    ;\n\n    // パーティクル描く\n    particles.invoke(\"draw\");\n\n    d\n      .restore()\n      .restore()\n    ;\n    \n    // 対比する\n    olds = s;\n    window.setTimeout(arguments.callee.curry(c+1), 16);\n  })(0);\n\n};\n\n// vim:sw=2:ts=2\n"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/a/x/v/axvj_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/a/x/v/axvj.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/a/x/v/axvj_100.jpg"},"description_html":"パーティクルくるくるくるくるくるくるくるくるクロック","modified_date":"2011-02-13 18:12:44","uid":"axvj","created_date":"2011-02-12 21:31:57","path":"axvj","description":"パーティクルくるくるくるくるくるくるくるくるクロック","statistic":{"forked":"0","favorite":"5","pageview":"2677"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"url":"http://jsdo.it/crispy/axvj","title":"Particle-cle clock"}