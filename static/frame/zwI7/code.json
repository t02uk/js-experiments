{"source":{"css":"body {\n margin: 0;\n padding: 0;\n overflow: hidden;\n}","html":"<canvas id=\"world\" width=\"456\" height=\"456\"></canvas>","lisence":"MIT","js":"window.onload = (function() {\n\n  var d = new DCore();\n\n  // pseudo random generator\n  var randomGen = function() {\n    var x = 1;\n    return function() {\n      x = (x * 22695477 + 1) & 0xffffffff;\n      return ((x >> 16) & 0x7fff) / 0x7fff;\n    };\n  };\n\n  function MockAudioContext() {}\n  MockAudioContext.prototype = {\n    createJavaScriptNode: function() {\n      return {\n        connect : function(){}\n      }\n    }\n  }\n\n  function Mixer() {\n  };\n  Mixer.prototype = {\n    prepare: function() {\n      this.ctx = new (window.AudioContext || window.webkitAudioContext || MockAudioContext)();\n      this.channel = 1;\n      this.bufferSize = 2 << 11;\n      this.notes = [];\n    },\n    createNode: function() {\n      return this.ctx.createJavaScriptNode(this.bufferSize, 1, 1);\n    },\n    addNote: function(note, p) {\n      this.notes.push(note);\n    },\n    update: function() {\n      var self = this;\n      for(var i = 0; i < self.notes.length; i++) {\n        if(!self.notes[i].hasNext()) {\n          self.notes[i].stop();\n          self.notes[i] = undefined;\n        }\n      }\n      self.notes = self.notes.compact();\n    }\n  };\n\n  function Note(volume, delay, p) {\n    this.seek = 0;\n    this.a = 18000;\n    this.delay = delay;\n    this.birthTime = +new Date();\n    this.p = p;\n    this.install();\n  }\n  Note.prototype = {\n    install: function() {\n\n      var seek = this.seek;\n      var a = this.a;\n      \n      this.jsNode = mixer.createNode();\n      var self = this;\n      var p = this.p;\n        \n      // connect js node -> panner\n      var pannerNode = this.parrentNode = mixer.ctx.createPanner();\n      pannerNode.connect(mixer.ctx.destination);\n      pannerNode.setPosition(p[0], p[1], p[2]);\n      this.jsNode.connect(pannerNode);\n\n      this.jsNode.onaudioprocess = function(evt) {\n        if(!self.readyForPlay()) return;\n\n        var sampleRate = evt.outputBuffer.sampleRate;\n        var length = evt.outputBuffer.length;\n        var buffer = evt.outputBuffer.getChannelData(0);\n\n        // fade out effect\n        for(var i = 0; i < length; i++) {\n          buffer[i] *= 0.3;\n        }\n\n        if(seek <= 10000) {\n          // fill buffer\n          for(var i = 0; i < length; i++) {\n            buffer[i] += Math.sin(a * a * 0.0000004 + a * 0.002) * Math.cos(seek / 10000) * 0.5;\n            seek++;\n            a -= 1;\n          }\n        }\n        self.seek = seek;\n        self.a = a;\n      };\n\n    },\n    readyForPlay: function() {\n      var passedTime = new Date() - this.birthTime;\n      return passedTime > this.delay;\n    },\n    hasNext: function() {\n      return this.seek < 18000;\n    },\n    stop: function() {\n      this.jsNode.disconnect();\n    }\n  }\n\n  var mixer = new Mixer();\n  mixer.prepare();\n    \n  var ln = 0;\n\n  (function(c) {\n    mixer.update();\n\n    var random = randomGen();\n\n    // ellipse back\n    d\n     .blend(\"source-over\")\n     .alpha(1)\n     .hsv(0, 0, ln)\n     .fillBack()\n    ;\n    // fade lightness of \n    // below values will be increased when Hanabi exploded\n    ln *= 0.5;\n\n    // set camera position\n    var cp = [Math.cos(c * 0.0023) * 200, Math.sin(c * 0.01) * 20 + 40, 0].rotatey(c * 0.003)\n    var gp = [0, 20 + Math.cos(c * 0.017) * 10, 0]\n    d\n     .gazeFrom(\n       cp,\n       gp\n     )\n    ;\n\n    // buoy\n    for(var i = 0; i < 64; i++) {\n      var x = random() * 150;\n      var z = random() * 150;\n      var y = Math.sin(x + z + c * 0.01) * 3;\n      d\n       .blend(\"lighter\")\n       .alpha(1)\n       .luminous([x, y, z].rotatey(i.toRadian() / 32), 0.1, 0.2, [\n         [0.00, [0xff, 0xff, 0xff]],\n         [1.00, [0x00, 0x00, 0x00]]\n       ])\n       .fill()\n      ;\n    }\n\n    // hanabi\n    for(var i = 0; i < 12; i++) {\n      // sub counter\n      var sc = ((c + (i >> 0) * 85) % 900);\n      // hanabi hue\n      var hue = random();\n      // \n      var ry = (sc * 0.01).toRadian() / 2;\n      // phase detect, based on sub counter\n      //   0 -> rising\n      //   1 -> stop\n      //   2 -> explode\n      //   3 -> wait\n      var phase = (sc < 40) ? 0 : (sc < 43) ? 1 : (sc < 93) ? 2 : 3;\n      // if not rising fix the value rx to 40\n      if(phase != 0) ry = (40 * 0.01).toRadian() / 2;\n      // calculate base position\n      var ym = 20 + random() * 10;\n      var rm = 0.2 + random() * 0.4;\n      var br = random() * 100 + 10;\n      var ba = random() * 100;\n      var bx = br * Math.cos(ba);\n      var bz = br * Math.sin(ba);\n      var by = ((phase == 0 || phase == 1) ? Math.sin(ry) : 1) * ym;\n      // draw each Hanabi particle\n      for(var j = 0; j < 50; j++) {\n        //\n        var p = [bx, by, bz];\n        // for rising logic\n        var bby = Math.sin(ry) * random() * 4 + random();\n        var bbx = Math.sin(ry) * random() * 1 * Math.sin(j);\n        var bbz = Math.sin(ry) * random() * 1 * Math.cos(j);\n        if(phase == 0 || phase == 2) {\n          p = p.translate([bbx, bby, bbz]);\n        }\n        \n        // for exploding logic\n        var ssc = sc - 38;\n        var r = Math.cos(ssc * 0.01) * rm * ssc;\n\n        var rxy = random() * 100;\n        var exy = [r, 0, 0].rotatey(rxy);\n        exy = exy.rotatea(random() * 100, [0, 0, 1].rotatey(rxy));\n\n        var ex = exy[0];\n        var ey = exy[1] - ssc * 0.09;\n        var ez = exy[2];\n        if(phase == 2) {\n          p = p.translate([ex, ey, ez]);\n        }\n\n        var a = 0.1;\n        if(phase == 1) {\n          a = sc % 0.1;\n          // luminous\n          ln += 0.005;\n        }\n\n        var x = random();\n        if(phase == 2) {\n          // sound\n          if(j == 0 && sc == 44) {\n            var dist = cp.distance(p);\n            var vc = gp.sub(cp).scale([1, 0, 1]).normalize();\n            var va = vc.rotatey(-0.25.toRadian()).normalize();\n            var vp = p.sub(cp);\n            var vz = vc.dot(vp);\n            var vx = va.dot(vp);\n            var vy = [0, 1, 0].dot(vp);\n            mixer.addNote(new Note(0.5, dist * 8, [vx, vy, vz].mul(0.01)));\n          }\n          var erased = ssc / 50 > x;\n        }\n\n        // draw on phase rising or explode\n        if(phase == 0 || phase == 2) {\n          if(!erased) {\n            // body\n            d\n             .blend(\"lighter\")\n             .alpha(a)\n             .luminous(p, 0.5, 0.9, [\n               [0.00, [hue, 0.3, 1.0].hsv()],\n               [0.70, [hue, 0.8, 0.8].hsv()],\n               [1.00, [hue, 0.3, 0.0].hsv()]\n              ])\n             .fill()\n            ;\n\n            // reflection\n            d\n             .blend(\"lighter\")\n             .alpha(a * 0.1)\n             .luminous(p.scale(1, -1, 1), 0.5, 0.9, [\n               [0.00, [hue, 0.3, 1.0].hsv()],\n               [0.30, [hue, 0.8, 0.8].hsv()],\n               [1.00, [hue, 0.3, 0.0].hsv()]\n              ])\n             .fill()\n            ;\n          }\n        }\n      }\n    }\n\n    setTimeout(arguments.callee.curry(c + 1), 33);\n  })(0);\n\n\n});\n// vim:sw=2:ts=2\n"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/z/w/I/zwI7_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/z/w/I/zwI7.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/z/w/I/zwI7_100.jpg"},"description_html":"時間差発声＋3D音響テスト<br />\r\n<br />\r\n音は自分で作っているため、Chromeの新しいバージョンでないと音がでません<br />\r\n動作確認　Chrome 21.0.1180.60 m<br />\r\n","modified_date":"2012-08-12 19:07:07","uid":"zwI7","created_date":"2012-08-12 19:00:52","path":"zwI7","description":"時間差発声＋3D音響テスト\r\n\r\n音は自分で作っているため、Chromeの新しいバージョンでないと音がでません\r\n動作確認　Chrome 21.0.1180.60 m\r\n","statistic":{"forked":"0","favorite":"1","pageview":"684"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"url":"http://jsdo.it/crispy/zwI7","title":"打ち上げ花火"}