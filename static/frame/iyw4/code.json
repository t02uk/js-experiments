{"source":{"css":"body { background-color: #333333; padding: 0; margin: 0; overflow: hidden; }\np{ position: absolute; z-index: 99; color: #cccccc; margin: 2px; padding: 0; font-family: Arial; font-size: 10px; }\na{ color: #f4f4f4; }","html":"<p>Double click to split. <b><a id=\"keyboardUp\" href=\"#\">Increase</a> / <a id=\"keyboardDown\" href=\"#\">decrease</a></b> size or <b><a id=\"keyboardLeft\" href=\"#\">Previous</a> / <a id=\"keyboardRight\" href=\"#\">Next</a></b> skin.</p>\n<canvas id='world'></canvas>","lisence":"MIT","js":"// forked from hakim's \"Blob\" http://jsdo.it/hakim/blob\n/**\n* Best seen in fullscreen: http://hakim.se/experiments/html5/blob/03/\n */\nBlobWorld = new function() {\n  \n  var img;\n  window.onload = function() {\n    img = document.createElement(\"img\");\n    img.src = \"http://dl.dropbox.com/u/3589634/resource/image/misawa.PNG\";\n    img.width = 200;\n    img.height = 200;\n  };\n  \n  var SCREEN_WIDTH = window.innerWidth;\n  var SCREEN_HEIGHT = window.innerHeight;\n  \n  var canvas;\n  var context;\n  var blobs = [];\n  \n  var dragBlob;\n  \n  var screenX = window.screenX;\n  var screenY = window.screenY;\n  \n  var mouseX = (window.innerWidth - SCREEN_WIDTH);\n  var mouseY = (window.innerHeight - SCREEN_HEIGHT);\n  var mouseIsDown = false;\n  var mouseDownOffset = { x: 0, y: 0 };\n  \n  // The bounds of the world\n  var worldRect = { x: 0, y: 0, width: 0, height: 0 };\n  \n  // The world gravity, applied to all blobs\n  var gravity = { x: 0, y: 1.2 };\n  \n  // A pair of blobs that should be merged\n  var mergeQueue = { blobA: -1, blobB: -1 };\n  \n  var skinIndex = 0;\n  var skins = [\n       { fillStyle: 'rgba(255,240,232,1.0)', strokeStyle: 'rgba(255,240,232,1.0)', lineWidth: 5, debug: false },\n       { fillStyle: '', strokeStyle: '', lineWidth: 0, debug: true },\n//     { fillStyle: 'rgba(0,0,0,0.1)', strokeStyle: 'rgba(255,255,255,1.0)', lineWidth: 6, debug: false },\n//       { fillStyle: 'rgba(0,230,110,1.0)', strokeStyle: 'rgba(0,0,0,1.0)', lineWidth: 2, debug: false },\n//       { fillStyle: 'rgba(255,255,0,1.0)', strokeStyle: 'rgba(0,0,0,1.0)', lineWidth: 4, debug: false },\n//       { fillStyle: 'rgba(255,255,255,1.0)', strokeStyle: 'rgba(0,0,0,1.0)', lineWidth: 4, debug: false }\n  ];\n  \n  this.init = function() {\n    \n    canvas = document.getElementById( 'world' );\n    \n    if (canvas && canvas.getContext) {\n      context = canvas.getContext('2d');\n      \n      // Register event listeners\n      document.addEventListener('mousemove', documentMouseMoveHandler, false);\n      canvas.addEventListener('mousedown', documentMouseDownHandler, false);\n      canvas.addEventListener('dblclick', documentDoubleClickHandler, false);\n      document.addEventListener('mouseup', documentMouseUpHandler, false);\n      document.addEventListener('touchstart', documentTouchStartHandler, false);\n      document.addEventListener('touchmove', documentTouchMoveHandler, false);\n      document.addEventListener('touchend', documentTouchEndHandler, false);\n      document.addEventListener('keydown', documentKeyDownHandler, false);\n      window.addEventListener('resize', windowResizeHandler, false);\n      \n      document.getElementById( 'keyboardUp' ).addEventListener('click', keyboardUpHandler, false);\n      document.getElementById( 'keyboardDown' ).addEventListener('click', keyboardDownHandler, false);\n      document.getElementById( 'keyboardLeft' ).addEventListener('click', keyboardLeftHandler, false);\n      document.getElementById( 'keyboardRight' ).addEventListener('click', keyboardRightHandler, false);\n      \n      createBlob( { x: SCREEN_WIDTH*0.5, y: SCREEN_HEIGHT*0.1 } );\n      \n      windowResizeHandler();\n      \n      setInterval( loop, 1000 / 60 );\n    }\n  };\n  \n  function createBlob( position ) {\n    var blob = new Blob();\n    \n    blob.position.x = position.x;\n    blob.position.y = position.y;\n    \n    blob.generateNodes();\n    \n    blobs.push( blob );\n  }\n  \n  function splitBlob( blob ) {\n    if( blob.quality > 8 ) {\n      blobs.push( blob.split() );\n    }\n  }\n  \n  function mergeBlobs( blobA, blobB ) {\n    var t = getTime();\n    \n    if( !blobs[blobA] || !blobs[blobB] ) {\n      return;\n    }\n    \n    if( t - blobs[blobA].lastSplitTime > 500 && t - blobs[blobB].lastSplitTime > 500 ) {\n      // Merge blobB with blobA\n      blobs[blobA].merge( blobs[blobB] );\n      \n      // Remove blobB since blobA will take over its body\n      blobs.splice( blobB, 1 );\n    }\n  }\n\n  function documentMouseMoveHandler(event) {\n    mouseX = event.clientX - (window.innerWidth - SCREEN_WIDTH) * .5;\n    mouseY = event.clientY - (window.innerHeight - SCREEN_HEIGHT) * .5;\n  }\n  \n  function documentMouseDownHandler(event) {\n    event.preventDefault();\n    \n    mouseIsDown = true;\n    \n    dragBlob = blobs[ findClosestBody( blobs, { x: mouseX, y: mouseY } ) ];\n    var closestNodeIndex = findClosestBody( dragBlob.nodes, { x: mouseX, y: mouseY } );\n    dragBlob.dragNodeIndex = closestNodeIndex;\n    \n    mouseDownOffset.y = 100;\n  }\n  \n  function documentMouseUpHandler(event) {\n    mouseIsDown = false;\n    \n    if( dragBlob ) {\n      dragBlob.dragNodeIndex = -1;\n      dragBlob = null;\n    }\n  }\n  \n  function documentTouchStartHandler(event) {\n    if(event.touches.length == 1) {\n      event.preventDefault();\n      \n      mouseIsDown = true;\n      \n      mouseX = event.touches[0].pageX - (window.innerWidth - SCREEN_WIDTH) * .5;\n      mouseY = event.touches[0].pageY - (window.innerHeight - SCREEN_HEIGHT) * .5;\n      \n      dragBlob = blobs[ findClosestBody( blobs, { x: mouseX, y: mouseY } ) ];\n      var closestNodeIndex = findClosestBody( dragBlob.nodes, { x: mouseX, y: mouseY } );\n      dragBlob.dragNodeIndex = closestNodeIndex;\n      \n      mouseDownOffset.y = 100;\n    }\n  }\n  \n  function documentTouchMoveHandler(event) {\n    if(event.touches.length == 1) {\n      event.preventDefault();\n\n      mouseX = event.touches[0].pageX - (window.innerWidth - SCREEN_WIDTH) * .5;\n      mouseY = event.touches[0].pageY - (window.innerHeight - SCREEN_HEIGHT) * .5;\n    }\n  }\n  \n  function documentTouchEndHandler(event) {\n    mouseIsDown = false;\n    \n    if( dragBlob ) {\n      dragBlob.dragNodeIndex = -1;\n      dragBlob = null;\n    }\n  }\n  \n  function documentDoubleClickHandler(event) {\n    var mouse = { x: mouseX, y: mouseY };\n    \n    var blob = blobs[findClosestBody( blobs, mouse )];\n    \n    if( distanceBetween( blob.position, mouse ) < blob.radius + 30 ) {\n      splitBlob( blob );\n    }\n  }\n  \n  function documentKeyDownHandler(event) {\n    switch( event.keyCode ) {\n      case 40:\n        changeBlobRadius( -10 );\n        event.preventDefault();\n        break;\n      case 38:\n        changeBlobRadius( 10 );\n        event.preventDefault();\n        break;\n      case 37:\n        changeSkin( -1 );\n        event.preventDefault();\n        break;\n      case 39:\n        changeSkin( 1 );\n        event.preventDefault();\n        break;\n    }\n  }\n  \n  function keyboardUpHandler(event) {\n    event.preventDefault();\n    changeBlobRadius( 20 );\n    }\n  \n  function keyboardDownHandler(event) {\n    event.preventDefault();\n    changeBlobRadius( -20 );\n  }\n  \n  function keyboardLeftHandler(event) {\n    event.preventDefault();\n    changeSkin( -1 );\n  }\n  \n  function keyboardRightHandler(event) {\n    event.preventDefault();\n    changeSkin( 1 );\n  }\n  \n  function changeSkin( offset ) {\n    skinIndex += offset;\n    skinIndex = skinIndex < 0 ? skins.length-1 : skinIndex;\n    skinIndex = skinIndex > skins.length-1 ? 0 : skinIndex;\n  }\n  \n  function changeBlobRadius( offset ) {\n    for( var i = 0, len = blobs.length; i < len; i++ ) {\n      blob = blobs[i];\n      \n      var oldRadius = blob.radius;\n      \n      blob.radius += offset;\n      blob.radius = Math.max( 40, Math.min( blob.radius, 280 ) );\n      \n      if( blob.radius != oldRadius ) {\n        blob.updateNormals();\n      }\n    }\n  }\n  \n  function findClosestBody( bodies, position ) {\n    var closestDistance = 9999;\n    var currentDistance = 9999;\n    var closestIndex = -1;\n    \n    for( var i = 0, len = bodies.length; i < len; i++ ) {\n      var body = bodies[i];\n      \n      currentDistance = distanceBetween( body.position, { x: position.x, y: position.y } );\n      \n      if( currentDistance < closestDistance ) {\n        closestDistance = currentDistance;\n        closestIndex = i;\n      }\n    }\n    \n    return closestIndex;\n  }\n  \n  function windowResizeHandler() {\n    SCREEN_WIDTH = window.innerWidth;\n    SCREEN_HEIGHT = window.innerHeight;\n    \n    canvas.width = SCREEN_WIDTH;\n    canvas.height = SCREEN_HEIGHT;\n    \n    worldRect.x = 3;\n    worldRect.y = 3;\n    worldRect.width = SCREEN_WIDTH-6;\n    worldRect.height = SCREEN_HEIGHT-6;\n  }\n\n  function loop() {\n    \n    var skin = skins[skinIndex];\n    \n    // The area around the dirty region to include in the clear\n    var dirtySpread = 80;\n    \n    var u1, u2, ulen, blob;\n    \n    // Clear the dirty rects of all blobs\n    for( u1 = 0, ulen = blobs.length; u1 < ulen; u1++ ) {\n      blob = blobs[u1];\n      \n      // Clear all pixels in the dirty region\n      context.clearRect(blob.dirtyRegion.left-dirtySpread,blob.dirtyRegion.top-dirtySpread,blob.dirtyRegion.right-blob.dirtyRegion.left+(dirtySpread*2),blob.dirtyRegion.bottom-blob.dirtyRegion.top+(dirtySpread*2));\n      \n      // Reset the dirty region so that it can be expanded anew\n      blob.dirtyRegion = { left: worldRect.x + worldRect.width, top: worldRect.y + worldRect.height, right: 0, bottom: 0 };\n    }\n    \n    // If there is a merge queued, solve it now\n    if( mergeQueue.blobA != -1 && mergeQueue.blobB != -1 ) {\n      mergeBlobs( mergeQueue.blobA, mergeQueue.blobB );\n      \n      mergeQueue.blobA = -1;\n      mergeQueue.blobB = -1;\n    }\n    \n    // If the mouse is down, start adding the velocity needed to move towards the mouse position\n    if( dragBlob ) {\n      dragBlob.velocity.x += ( ( mouseX + mouseDownOffset.x ) - dragBlob.position.x ) * 0.01;\n      dragBlob.velocity.y += ( ( mouseY + mouseDownOffset.y ) - dragBlob.position.y ) * 0.01;\n    }\n    \n    for( u1 = 0, ulen = blobs.length; u1 < ulen; u1++ ) {\n      blob = blobs[u1];\n      \n      for( u2 = 0; u2 < ulen; u2++ ) {\n        var otherBlob = blobs[u2];\n        \n        if( otherBlob != blob ) {\n          var distance = distanceBetween( { x: blob.position.x, y: blob.position.y }, { x: otherBlob.position.x, y: otherBlob.position.y } );\n          \n          if( distance < blob.radius + otherBlob.radius ) {\n            mergeQueue.blobA = u1;\n            mergeQueue.blobB = u2;\n          }\n        }\n      }\n      \n      // Track window movement\n      blob.velocity.x += ( window.screenX - screenX ) * (0.04 + (Math.random()*0.1));\n      blob.velocity.y += ( window.screenY - screenY ) * (0.04 + (Math.random()*0.1));\n      \n      var friction = { x: 1.035, y: 1.035 };\n      \n      // Enforce horizontal world bounds\n      if( blob.position.x > worldRect.x + worldRect.width ) {\n        blob.velocity.x -= ( blob.position.x - worldRect.width ) * 0.05;\n        friction.y = 1.07;\n      }\n      else if( blob.position.x < worldRect.x ) {\n        blob.velocity.x += Math.abs( worldRect.x - blob.position.x ) * 0.05;\n        friction.y = 1.07;\n      }\n      \n      // Enforce vertical world bounds\n      if( blob.position.y > worldRect.y + worldRect.height ) {\n        blob.velocity.y -= ( blob.position.y - worldRect.height ) * 0.05;\n        friction.x = 1.07;\n      }\n      else if( blob.position.y < worldRect.y ) {\n        blob.velocity.y += Math.abs( worldRect.y - blob.position.y ) * 0.05;\n        friction.x = 1.07;\n      }\n      \n      // Gravity\n      blob.velocity.x += gravity.x;\n      blob.velocity.y += gravity.y;\n      \n      // Friction\n      blob.velocity.x /= friction.x;\n      blob.velocity.y /= friction.y;\n      \n      // Apply the velocity to the entire blob\n      blob.position.x += blob.velocity.x;\n      blob.position.y += blob.velocity.y;\n      \n      var i, j, len, node, joint, position;\n      \n      // Update all node ghosts (previous positions). All nodes need to be synced before the below\n      // calculation loop to avoid tearing between the first nodes\n      for (i = 0, len = blob.nodes.length; i < len; i++) {\n        node = blob.nodes[i];\n        \n        node.ghost.x = node.position.x;\n        node.ghost.y = node.position.y;\n      }\n      \n      var dragNode = blob.nodes[blob.dragNodeIndex];\n      if( dragNode ) {\n        var angle = Math.atan2( mouseY - (blob.position.y-80), mouseX - blob.position.x );\n        \n        blob.rotation += ( angle - blob.rotation ) * 0.03;\n        blob.updateNormals();\n      }\n      \n      // Calculation loop\n      for (i = 0, len = blob.nodes.length; i < len; i++) {\n        node = blob.nodes[i];\n        \n        // Move towards the normal target\n        node.normal.x += ( node.normalTarget.x - node.normal.x ) * 0.05;\n        node.normal.y += ( node.normalTarget.y - node.normal.y ) * 0.05;\n        \n        // This point will be used as the new position for this node, after all factors have been applied\n        position = { x: blob.position.x, y: blob.position.y };\n        \n        // Apply the joints\n        for( j = 0; j < node.joints.length; j++ ) {\n          joint = node.joints[j];\n          \n          // Determine the strain on the joints\n          var strainX = ( (joint.node.ghost.x - node.ghost.x) - (joint.node.normal.x - node.normal.x) );\n          var strainY = ( (joint.node.ghost.y - node.ghost.y) - (joint.node.normal.y - node.normal.y) );\n          \n          position.x += strainX * joint.strength;\n          position.y += strainY * joint.strength;\n        }\n        \n        // Offset by the normal\n        position.x += node.normal.x;\n        position.y += node.normal.y;\n        \n        // Apply the drag offset (if applicable)\n        if( i == blob.dragNodeIndex ) {\n          position.x += ( mouseX - position.x ) * 0.98;\n          position.y += ( mouseY - position.y ) * 0.98;\n        }\n        \n        // Apply the calculated position to the node (with easing)\n        node.position.x += ( position.x - node.position.x ) * 0.1;\n        node.position.y += ( position.y - node.position.y ) * 0.1;\n        \n        // Limit the node position to screen bounds\n        node.position.x = Math.max( Math.min( node.position.x, worldRect.x + worldRect.width ), worldRect.x );\n        node.position.y = Math.max( Math.min( node.position.y, worldRect.y + worldRect.height ), worldRect.y );\n        \n        // Expand the dirty rect if needed\n        blob.dirtyRegion.left = Math.min(blob.dirtyRegion.left, node.position.x);\n        blob.dirtyRegion.top = Math.min(blob.dirtyRegion.top, node.position.y);\n        blob.dirtyRegion.right = Math.max(blob.dirtyRegion.right, node.position.x);\n        blob.dirtyRegion.bottom = Math.max(blob.dirtyRegion.bottom, node.position.y);\n      }\n      \n      if( !skin.debug ) {\n           context.beginPath();\n        context.fillStyle = skin.fillStyle;\n        context.strokeStyle = skin.strokeStyle;\n        context.lineWidth = skin.lineWidth;\n      }\n      \n      var cn = getArrayElementByOffset( blob.nodes, 0, -1 ); // current node\n      var nn = getArrayElementByOffset( blob.nodes, 0, 0 ); // next node\n      \n      // Move to the first anchor\n      context.moveTo( cn.position.x + ( nn.position.x - cn.position.x ) / 2, cn.position.y + ( nn.position.y - cn.position.y ) / 2 );\n      \n      // Caluculate center position\n      var center = {x: 0, y: 0};\n      for (i = 0, len = blob.nodes.length; i < len; i++) {\n        cn = getArrayElementByOffset( blob.nodes, i, 0 );\n        center.x += cn.position.x;\n        center.y += cn.position.y;\n      }\n      center.x /= len;\n      center.y /= len;\n    \n      // Rendering loop\n      for (i = 0, len = blob.nodes.length; i < len; i++) {\n        cn = getArrayElementByOffset( blob.nodes, i, 0 );\n        nn = getArrayElementByOffset( blob.nodes, i, 1 );\n        \n        if( skin.debug ) {\n          context.beginPath();\n          context.lineWidth = 1;\n          context.strokeStyle = \"#ababab\";\n          \n          for( j = 0; j < cn.joints.length; j++ ) {\n            joint = cn.joints[j];\n            context.moveTo( cn.position.x, cn.position.y );\n            context.lineTo( joint.node.position.x, joint.node.position.y );\n          }\n          \n          context.stroke();\n          \n          context.beginPath();\n          context.fillStyle = i == 0? \"#00ff00\" : \"#dddddd\";\n          context.arc(cn.position.x, cn.position.y, 5, 0, Math.PI*2, true);\n          context.fill();\n        }\n        else {\n          context.quadraticCurveTo( cn.position.x, cn.position.y, cn.position.x + ( nn.position.x - cn.position.x ) / 2, cn.position.y + ( nn.position.y - cn.position.y ) / 2 );\n        }\n      }\n      \n      if( skin.debug ) {\n//        context.beginPath();\n//        context.fillStyle = \"rgba(100,255,100,0.3)\";\n//        context.fillRect(blob.dirtyRegion.left-dirtySpread,blob.dirtyRegion.top-dirtySpread,blob.dirtyRegion.right-blob.dirtyRegion.left+(dirtySpread*2),blob.dirtyRegion.bottom-blob.dirtyRegion.top+(dirtySpread*2));\n//        context.fill();\n      }\n      \n      context.stroke();\n      context.fill();\n  \n      // Rendering Misawa face\n      for (i = 0, len = blob.nodes.length; i < len; i++) {\n        cn = getArrayElementByOffset( blob.nodes, i, 0 );\n        nn = getArrayElementByOffset( blob.nodes, i, 1 );\n        var radA = (i / len) * Math.PI * 2;\n        var radB = ((i + 1) / len) * Math.PI * 2;\n        drawTriangle(context, img,\n        [\n          center.x, center.y,\n          cn.position.x, cn.position.y,\n          nn.position.x, nn.position.y\n        ],\n        [\n          0.5, 0.5,\n          0.5 * Math.cos(radA) + 0.5, 0.5 * Math.sin(radA) + 0.5,\n          0.5 * Math.cos(radB) + 0.5, 0.5 * Math.sin(radB) + 0.5\n        ]\n        );\n      }\n\n    }\n    \n    screenX = window.screenX;\n    screenY = window.screenY;\n  }\n    \n  \n};\n\nfunction Blob() {\n  this.position = { x: 0, y: 0 };\n  this.velocity = { x: 0, y: 0 };\n  this.radius = 120;\n  this.quality = 32;\n  this.nodes = [];\n  this.rotation = -Math.PI * 0.5;\n  this.dragNodeIndex = -1;\n  this.dirtyRegion = { left: 0, top: 0, right: 0, bottom: 0 };\n  this.lastSplitTime = 0;\n  \n  this.generateNodes = function() {\n    this.nodes = [];\n    \n    var i, n;\n    \n    for (i = 0; i < this.quality; i++) {\n      n = {\n        normal: { x: 0, y: 0 },\n        normalTarget: { x: 0, y: 0 },\n        position: { x: this.position.x, y: this.position.y },\n        ghost: { x: this.position.x, y: this.position.y },\n        angle: 0\n      };\n      \n      this.nodes.push( n );\n    }\n    \n    this.updateJoints();\n    \n    this.updateNormals();\n  };\n  \n  this.updateJoints = function() {\n    for (var i = 0; i < this.quality; i++) {\n      var n = this.nodes[i];\n      \n      n.joints = [\n        { \n          node: getArrayElementByOffset( this.nodes, i, -1 ),\n          strength: 2.2\n        },\n        { \n          node: getArrayElementByOffset( this.nodes, i, 1 ),\n          strength: 2.2\n        }\n      ];\n      \n      n.joints.push( { \n        node: getArrayElementByOffset( this.nodes, i, -2 ),\n        strength: 2.2\n      } );\n      \n      n.joints.push( { \n        node: getArrayElementByOffset( this.nodes, i, 2 ),\n        strength: 2.2\n      } );\n      \n    }\n  };\n  \n  this.updateNormals = function() {\n    var i, j, n;\n    \n    for (i = 0; i < this.quality; i++) {\n      \n      var n = this.nodes[i];\n      \n      if( this.dragNodeIndex != -1 ) {\n        j = i - this.dragNodeIndex;\n        j = j < 0 ? this.quality + j : j;\n      }\n      else {\n        j = i;\n      }\n      \n      n.angle = ( (j / this.quality ) * Math.PI * 2 ) + this.rotation;\n      \n      n.normalTarget.x = Math.cos( n.angle ) * this.radius;\n      n.normalTarget.y = Math.sin( n.angle ) * this.radius;\n      \n      if( n.normal.x == 0 && n.normal.y == 0 ) {\n        n.normal.x = n.normalTarget.x;\n        n.normal.y = n.normalTarget.y;\n      }\n    }\n  };\n  \n  this.split = function() {\n    \n    var velocitySpread = this.radius / 10;\n    var nodeSpread = Math.round( this.nodes.length * 0.5 );\n    var radiusSpread = this.radius * 0.5;\n    \n    var sibling = new Blob();\n    \n    sibling.position.x = this.position.x;\n    sibling.position.y = this.position.y;\n    \n    sibling.velocity.x = velocitySpread;\n    sibling.velocity.y = this.velocity.y;\n    \n    sibling.nodes = [];\n    \n    var i = 0;\n    while( i++ < nodeSpread ) {\n      sibling.nodes.push( this.nodes.shift() );\n    }\n    \n    sibling.radius = radiusSpread;\n    sibling.quality = sibling.nodes.length;\n    \n    this.velocity.x = -velocitySpread;\n    this.radius = radiusSpread;\n    this.quality = this.nodes.length;\n    \n    this.dragNodeIndex = -1;\n    this.updateJoints();\n    this.updateNormals();\n    \n    sibling.dragNodeIndex = -1;\n    sibling.updateJoints();\n    sibling.updateNormals();\n    \n    sibling.lastSplitTime = getTime();\n    this.lastSplitTime = getTime();\n    \n    return sibling;\n    \n  };\n  \n  this.merge = function( sibling ) {\n    this.velocity.x *= 0.5;\n    this.velocity.y *= 0.5;\n    \n    this.velocity.x += sibling.velocity.x * 0.5;\n    this.velocity.y += sibling.velocity.y * 0.5;\n    \n    while( sibling.nodes.length ) {\n      this.nodes.push( sibling.nodes.shift() );\n    }\n    \n    this.quality = this.nodes.length;\n    this.radius += sibling.radius;\n    \n    this.dragNodeIndex = -1;\n    \n    this.updateNormals();\n    this.organizeNodesByProximity();\n    this.updateJoints();\n  };\n  \n  this.organizeNodesByProximity = function() {\n    var i, j, outer, inner;\n    \n    var closestDistance, currentDistance, closestIndex;\n    \n    var newNodes = this.nodes.concat();\n    var blackListed = [];\n    \n    for (i = 0; i < this.quality; i++) {\n      outer = newNodes[i];\n      \n      currentDistance = 9999;\n      closestDistance = 9999;\n      closestIndex = -1;\n      \n      for(j = 0; j < this.quality; j++) {\n        inner = newNodes[j];\n        \n        currentDistance = distanceBetween( inner.position, outer.position );\n        \n        if( currentDistance < closestDistance && blackListed.indexOf(inner) === -1 ) {\n          closestDistance = currentDistance;\n          closestIndex = j;\n        }\n      }\n      \n      this.nodes[i] = newNodes[closestIndex];\n    }\n    \n  };\n}\n\nfunction getArrayElementByOffset( array, index, offset ) {\n  if( array[index+offset] ) {\n    return array[index+offset];\n  }\n  \n  if( index+offset > array.length-1 ) {\n    return array[index - array.length + offset];\n  }\n  \n  if( index+offset < 0 ) {\n    return array[array.length + ( index + offset )];\n  }\n}\n\nfunction sortByField( list, field ) {\n  var sortOnField = function( a, b ) {\n    return a[field] - b[field];\n  };\n  \n  list.sort( sortOnField );\n}\n\nfunction getTime() {\n  return new Date().getTime();\n}\n\nfunction distanceBetween(p1,p2) {\n  var dx = p2.x-p1.x;\n  var dy = p2.y-p1.y;\n  return Math.sqrt(dx*dx + dy*dy);\n}\n\n\n// 参考 http://d.hatena.ne.jp/keyword/%A5%D1%A5%D5%A5%A9%A1%BC%A5%DE%A5%F3%A5%B9\nfunction M22()\n{\n  this._11 = 1;\n  this._12 = 0;\n  this._21 = 0;\n  this._22 = 1;\n}\n\nM22.prototype.getInvert = function()\n{\n  var out = new M22();\n  var det = this._11 * this._22 - this._12 * this._21;\n  if (det > -0.0001 && det < 0.0001)\n    return null;\n\n  out._11 = this._22 / det;\n  out._22 = this._11 / det;\n\n  out._12 = -this._12 / det;\n  out._21 = -this._21 / det;\n\n  return out;\n}\n\nfunction drawTriangle(g, img, vertex_list, uv_list)\n{\n  if(!img) return;\n  var _Ax = vertex_list[2] - vertex_list[0];\n  var _Ay = vertex_list[3] - vertex_list[1];\n  var _Bx = vertex_list[4] - vertex_list[0];\n  var _By = vertex_list[5] - vertex_list[1];\n\n  var Ax = (uv_list[2] - uv_list[0]) * img.width;\n  var Ay = (uv_list[3] - uv_list[1]) * img.height;\n  var Bx = (uv_list[4] - uv_list[0]) * img.width;\n  var By = (uv_list[5] - uv_list[1]) * img.height;\n\n  var m = new M22();\n  m._11 = Ax;\n  m._12 = Ay;\n  m._21 = Bx;\n  m._22 = By;\n  var mi = m.getInvert();\n  if (!mi) return;\n  var a, b, c, d;\n\n  a = mi._11 * _Ax + mi._12 * _Bx;\n  c = mi._21 * _Ax + mi._22 * _Bx;\n\n  b = mi._11 * _Ay + mi._12 * _By;\n  d = mi._21 * _Ay + mi._22 * _By;\n\n  g.save();\n  g.beginPath();\n  g.moveTo(vertex_list[0], vertex_list[1]);\n  g.lineTo(vertex_list[2], vertex_list[3]);\n  g.lineTo(vertex_list[4], vertex_list[5]);\n  g.clip();\n\n  g.transform(a, b, c, d,\n    vertex_list[0] - (a * uv_list[0] * img.width + c * uv_list[1] * img.height),\n    vertex_list[1] - (b * uv_list[0] * img.width + d * uv_list[1] * img.height));\n  g.drawImage(img, 0, 0);\n  g.restore();\n}\n\nBlobWorld.init();\n  \n  "},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/i/y/w/iyw4_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/i/y/w/iyw4.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/i/y/w/iyw4_100.jpg"},"description_html":"ミサワは足す(Fork)んじゃなくて、混ぜる(mashup?)べきネタだろうと試作。<br />\n・ginpeiさんのCSS3のミサワ <a  href=\"http://jsdo.it/ginpei/jXNb\">http://jsdo.it/ginpei/jXNb</a>  + hakimさんのBlob <a  href=\"http://jsdo.it/hakim/blob\">http://jsdo.it/hakim/blob</a><br />\n注)CSS3じゃなくて画像としてキャプチャさせて頂きました<br />\n<br />\njsdo.itには、もっと\"混ぜてみた\"なネタがあっても良いね<br />\n(追記) 分割後にもちもち感が損なわれるバグを修正","parent":{"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/v/K/4/vK4q_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/v/K/4/vK4q.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/v/K/4/vK4q_100.jpg"},"modified_date":"2010-07-03 05:20:06","uid":"vK4q","created_date":"2010-07-01 05:43:51","path":"blob","description":"Best seen in fullscreen: http://hakim.se/experiments/html5/blob/03/\n","statistic":{"forked":"30","favorite":"42","pageview":"39449"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/d/a/7/5/da752413881275c8a93e9adaa1a17d34da5cf9f4_100.jpg","name":"hakim"},"url":"http://jsdo.it/hakim/blob","title":"Blob"},"modified_date":"2011-02-16 23:51:08","uid":"iyw4","created_date":"2011-02-16 00:24:25","path":"iyw4","description":"ミサワは足す(Fork)んじゃなくて、混ぜる(mashup?)べきネタだろうと試作。\n・ginpeiさんのCSS3のミサワ http://jsdo.it/ginpei/jXNb  + hakimさんのBlob http://jsdo.it/hakim/blob\n注)CSS3じゃなくて画像としてキャプチャさせて頂きました\n\njsdo.itには、もっと\"混ぜてみた\"なネタがあっても良いね\n(追記) 分割後にもちもち感が損なわれるバグを修正","statistic":{"forked":"1","favorite":"9","pageview":"4208"},"url":"http://jsdo.it/crispy/iyw4","user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"title":"Misawa Blob forked from: Blob"}