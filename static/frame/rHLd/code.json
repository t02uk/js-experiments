{"source":{"css":"* {\n    margin:0px; padding: 0px;\n}\nbody {\n    background-color: #000;\n    overflow: hidden;\n}\n\n","html":"<!--\njsdo.itでCoffeeScriptを試す場合のデモです\nJavaScript領域に前後を/*と*/でくくってCoffeeScriptを記述してください\njQueryが使用できます（他に必要なライブラリがあれば「＋」から読みこめば実行できます）\n-->\n<script src=\"http://jashkenas.github.com/coffee-script/extras/coffee-script.js\"></script>\n<script src=\"http://jsrun.it/lib/prototype-1.6.1/js\"></script>\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js\"></script>\n<script>\n$(function () {\n  //    var js = CoffeeScript.compile(jQuery('script:last').text().replace(/^[\\s\\S]*?\\/\\*/, '').replace(/\\*\\/\\s*$/, ''));\n  //  eval(js)\n});\n</script>\n<canvas id='world'></canvas>>","lisence":"MIT","js":"// forked from kyo_ago's \"CoffeeScript出来るかな\" http://jsdo.it/kyo_ago/gAoN\n//以下のコメントアウト内にCoffeeScriptを記述してください。\n//コード開始から/＊までは無視されます。\n/*\nwindow.onload = (e)->\n\n  main = (() ->\n\n    # random\n    random = (x=1) -> () ->\n      x = (x * 22695477 + 1) & 0xffffffff\n      ((x >> 16) & 0x7fff) / 0x7fff\n\n    (() ->\n      lastTime = 0\n      org_setTimeout = window.setTimeout\n      window.setTimeout = (func, wait) ->\n        realWait = if lastTime then wait else wait - (new Date() - lastTime)\n        realWait = 1 if realWait <= 0\n        lastTime = +new Date()\n        org_setTimeout(func, realWait)\n    )()\n\n    # create my library\n    d = new DCore()\n\n    # observe key event\n    keys = []\n    ((keys, target) ->\n      flipOrFlop = (flag) ->\n        (e) ->\n          if e.keyCode in target\n            keys[e.keyCode] = flag\n            e.preventDefault?() ? e.returnValue = false\n\n      window.addEventListener(\"keydown\", flipOrFlop(true), false)\n      window.addEventListener(\"keyup\", flipOrFlop(false), false)\n\n    )(keys, [37,38,39,40,32])\n\n    # definition of screen\n    Screen =\n      left: 0.2\n      right: 0.8\n      top: 0.0\n      bottom: 1.0\n      width: 0.6\n      height: 1.0\n\n    # manager of score\n    class Score\n      constructor: ->\n        @score = 0\n        @pool = 0\n      add: (x) ->\n        @pool ?= x; @pool += x\n      act: () ->\n        if @pool > 0\n          @pool -= 1\n          @score += 1\n      draw: () ->\n        score = (\"0000#{@score}\").substr(-4, 4)\n        d\n         .font(\"monospace\", 0.04, \"bold\")\n         .rgb(0x33, 0x33, 0x99)\n         .textAlign(\"right\")\n         .fillText(\"SCORE #{score}\", [0.99, 0.01])\n\n    # enemy\n    class Enemy\n      size: 0.04\n      accell: 0.01\n      damage: () ->\n        @damaged = true\n        @life--\n        unless @alive() then score.add(10)\n      alive: () ->\n        @life > 0\n      launchTypes: [\n        () ->\n          new EnemyAmmo(@p, [0.0, 0.005], @hue)\n        ,() ->\n          asp = player.p.sub(@p).normalize(0.01)\n          [\n            new EnemyAmmo(@p, asp.rotate( 0.1), @hue)\n            new EnemyAmmo(@p, asp.rotate(-0.1), @hue)\n          ]\n        ,() ->\n          asp = player.p.sub(@p).normalize(0.01)\n          new EnemyAmmo(@p, asp, @hue)\n      ]\n      constructor: (p, life) ->\n        @p = p\n        @life = life ? 5\n        @type = ((x) ->\n          a = $R(0, 1).randf()\n          if 0.0 <= a < 0.5 then 0\n          else if 0.5 <= a < 0.8 then 1\n          else 2\n        )()\n        @hue = [0.0, 0.25, 0.6][@type]\n        @launchType = @launchTypes[@type]\n      move: (sp) ->\n        @p = @p.add(sp.mul(@accell))\n      act: () ->\n        @damaged = false\n        @count ?= 0; @count++\n        if(@count % 20 is 0)\n          ammos.push(@launchType.call(@))\n        this\n      draw: () ->\n        s = if @count < 4 then @count * 0.004 else 0\n        d\n         .quads(Geo\n           .rect(true)\n           .scale((@size + @damaged * (5 - @life) * 0.0075 - s).arize(2))\n           .translate(@p))\n         .blend(\"source-over\")\n         .alpha(0.4 + @life * 0.15)\n         .hsv(@hue, 0.1, 0.95)\n         .fill()\n         .hsv(@hue, 0.3, 0.8)\n         .stroke()\n\n    # ammo\n    class Ammo\n      valid: () ->\n        return -0.1 < @p[0] < 1.1 and -0.1 < @p[1] < 1.1\n\n    # ammo of player\n    class PlayerAmmo extends Ammo\n      size: 0.02\n      constructor: () ->\n        [@p, @sp] = $A(arguments)\n      act: () ->\n        @count ?= 0; @count++\n        @p = @p.add(@sp.mul(1 + @count * 0.1))\n      draw: () ->\n        d\n         .rgb(0x33, 0xcc, 0x66)\n         .alpha(0.5)\n         .lineWidth(0.005)\n         .quads(Geo.rect(true)\n           .rotate(@count / 10)\n           .scale(@size.arize(2))\n           .translate(@p))\n         .stroke()\n\n    # ammo of enemy\n    class EnemyAmmo extends Ammo\n      size: 0.015\n      constructor: () ->\n        [@p, @sp, @hue] = $A(arguments)\n        buzzed = false\n\n      act: () ->\n        @p = @p.add(@sp)\n      draw: () ->\n        d\n          .hsv(@hue, 0.7, (if @buzzed then 0.5 else 0.8))\n         .alpha(0.8)\n         .lineWidth(0.01)\n         .quads(Geo.rect(true)\n           .scale(@size.arize(2))\n           .translate(@p))\n         .stroke()\n\n\n    # bit\n    class Bit\n      vissize: 0.015\n      size: 0.045\n      dist: 0.06\n      constructor: (player, p, d) ->\n        @player = player\n        @p = p.clone()\n        @d = d\n        @reserved = 0\n        @bound = true\n      act: () ->\n\n        @count ?= 0; @count++\n\n        if @bound\n          _p = [0, @dist].rotate((@count / 6) + @d.toRadian()).add(@player.p)\n        else\n          _p = @p\n\n\n        @p = @p.add(_p).mul(0.5)\n\n        if @reserved isnt 0\n          ammos.push(\n            new PlayerAmmo(@p, [Math.sin(@count / 6) * 0.003, -0.02]))\n          @reserved--\n\n      launch: () ->\n        @player.launch()\n        @reserved += 1\n      bindToggle: () ->\n        @bound ^= true\n      draw: () ->\n        d\n         .quads(Geo\n           .rect(true)\n           .rotate(@count / 10)\n           .scale(@vissize.arize(2))\n           .translate(@p))\n         .blend(\"source-over\")\n         .alpha(0.35)\n         .lineWidth(0.008)\n         .rgb(0x33, 0x66, 0x99)\n         .stroke()\n\n\n    class Player\n      size: 0.01\n      sieldsize: 0.04\n      accell: 0.01\n      constructor: (p) ->\n        @p = p\n      move: (sp) ->\n        @p = @p.add(sp.mul(@accell))\n        @p[0] = ((x) ->\n          if x < Screen.left then Screen.left\n          else if x > Screen.right then Screen.right\n          else x\n        )(@p[0])\n        @p[1] = ((x) ->\n          if x < Screen.top then Screen.top\n          else if x > Screen.bottom then Screen.bottom\n          else x\n        )(@p[1])\n      launch: () ->\n        @reserved ?= 0; @reserved++\n        ammos.push(\n          new PlayerAmmo(@p, [0, -0.01]))\n      kill: () ->\n        @killed = true\n      act: () ->\n        @count ?= 0; @count++\n        if(@count % 4 is 0)\n          ammos.push(\n            new PlayerAmmo(@p, [0, -0.01]))\n        if(@reserved > 0)\n          ammos.push(\n            new PlayerAmmo(@p, [0, -0.01]))\n          @reserved--\n        this\n      draw: () ->\n        d\n         .quads(Geo\n           .rect(true)\n           .rotate(@count / 10)\n           .scale(@sieldsize.arize(2))\n           .translate(@p))\n         .blend(\"source-over\")\n         .alpha(0.3)\n         .rgb(0xaa, 0xff, 0xff)\n         .fill()\n         .alpha(0.9)\n         .rgb(0x77, 0x77, 0xcc)\n         .stroke()\n         .alpha(0.9)\n         .rgb(0xff, 0x99, 0x99)\n         .quads(Geo\n           .rect(true)\n           .scale((@size).arize(2))\n           .translate(@p))\n         .fill()\n\n\n    # first initialize\n    player = new Player([0.5, 0.8])\n    bits = [0...3].map((x) ->\n      new Bit(player, player.p, x / 3))\n\n    ammos = []\n    enemies = []\n    score = new Score()\n\n    # main loop\n    ((c, lv=0) ->\n\n      # enemy generation control\n      if c % (150 - lv) is 0\n        if enemies.length is 0 then score.add(lv * 3)\n        (3 + ~~(lv / 4)).times((x) ->\n          enemies.push(\n            new Enemy([$R(Screen.left, Screen.right).randf(), $R(0.03, 0.1).randf()]))\n        )\n        lv++\n\n      # background\n      d\n       .blend(\"copy\")\n       .alpha(1)\n       .rgb(0xea, 0xe9, 0xff)\n       .fillBack()\n\n      # draw tiles\n      rand = random()\n      [0..100].each((x) ->\n        p =\n        [\n          (x % 10 * Screen.width) * 0.1 + Screen.left,\n          rand() * 2.5 - 0.25,\n        ]\n\n\n        s = (~(x * x / 1000.0) / 100) + 0.1\n        s = x / 800 + 0.02\n\n        p[1] += c / 10 * s + 0.15\n        p[1] %= 2.0\n        p[1] -= 0.5\n\n        d\n         .quads(Geo.rect(true)\n           .scale(s.arize(2))\n           .translate(p))\n         .blend(\"source-over\")\n         .alpha(0.15)\n         .rgb(0xaa, 0xaa, 0xff)\n         .fill()\n         .lineWidth(0.01)\n         .stroke()\n      )\n\n      # key control\n      if keys[37] then player.move([-1,  0])\n      if keys[38] then player.move([ 0, -1])\n      if keys[39] then player.move([ 1,  0])\n      if keys[40] then player.move([ 0,  1])\n      if keys[32] then bits.each((x) -> x.bindToggle())\n      keys[32] = false\n\n      # delete killed enemy\n      enemies = enemies.select((x) -> x.alive())\n\n      # control\n      [\n        player,\n        enemies,\n        bits\n      ].shallowFlatten().each(\n        (x) -> x.act()\n      )\n\n      collisionTest = (lhs, rhs)->\n        lhs.p.distance(rhs.p) < lhs.size + rhs.size\n\n      # hit ammo test\n      ammos = ammos.flatten().select((ammo) ->\n        ammo.act()\n        if not ammo.valid() then false\n        else if ammo instanceof EnemyAmmo\n          bits.each((bit) ->\n            if collisionTest(ammo, bit)\n              unless ammo.buzzed then bit.launch()\n              unless ammo.buzzed then score.add(1)\n              ammo.buzzed = true\n          )\n          if collisionTest(ammo, player) then player.kill()\n          true\n        else if ammo instanceof PlayerAmmo\n          enemy = enemies.find((enemy) ->\n            collisionTest(ammo, enemy))\n          enemy?.damage()\n          not enemy\n      ).map((ammo) ->\n        ammo.draw()\n        ammo\n      )\n\n      # drawing\n      [\n        player,\n        enemies,\n        bits\n      ].shallowFlatten().each(\n        (x) -> x.draw()\n      )\n\n      # ellipse left/right side\n      d\n       .alpha(0.8)\n       .rgb(0xbb, 0xcc, 0xff)\n        # fill left\n       .quads(Geo.rect(false)\n         .scale([Screen.left, Screen.height]))\n       .fill()\n        # fill left\n       .quads(Geo.rect(false)\n         .scale([Screen.left, Screen.height])\n         .translate([Screen.right, Screen.top]))\n       .fill()\n\n      # control of score\n      score.act()\n      score.draw()\n\n      unless player.killed\n        window.setTimeout(arguments.callee.curry(c+1, lv), 33)\n      else\n        if confirm(\"\"\"\n        Game is over. (Score #{score.score})\n        Continue?\n        \"\"\") then main()\n    )(0)\n  )\n  main()\n\n    \n\n\n# vim:sw=2:ts=2\n\n\n*/\n(function() {\n  var __indexOf = Array.prototype.indexOf || function(item) {\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (this[i] === item) return i;\n    }\n    return -1;\n  }, __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {\n    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor;\n    child.__super__ = parent.prototype;\n    return child;\n  };\n  window.onload = function(e) {\n    var main;\n    main = (function() {\n      var Ammo, Bit, Enemy, EnemyAmmo, Player, PlayerAmmo, Score, Screen, ammos, bits, d, enemies, keys, player, random, score;\n      random = function(x) {\n        if (x == null) {\n          x = 1;\n        }\n        return function() {\n          x = (x * 22695477 + 1) & 0xffffffff;\n          return ((x >> 16) & 0x7fff) / 0x7fff;\n        };\n      };\n      (function() {\n        var lastTime, org_setTimeout;\n        lastTime = 0;\n        org_setTimeout = window.setTimeout;\n        return window.setTimeout = function(func, wait) {\n          var realWait;\n          realWait = lastTime ? wait : wait - (new Date() - lastTime);\n          if (realWait <= 0) {\n            realWait = 1;\n          }\n          lastTime = +new Date();\n          return org_setTimeout(func, realWait);\n        };\n      })();\n      d = new DCore();\n      keys = [];\n      (function(keys, target) {\n        var flipOrFlop;\n        flipOrFlop = function(flag) {\n          return function(e) {\n            var _ref, _ref2;\n            if (_ref = e.keyCode, __indexOf.call(target, _ref) >= 0) {\n              keys[e.keyCode] = flag;\n              return (_ref2 = typeof e.preventDefault == \"function\" ? e.preventDefault() : void 0) != null ? _ref2 : e.returnValue = false;\n            }\n          };\n        };\n        window.addEventListener(\"keydown\", flipOrFlop(true), false);\n        return window.addEventListener(\"keyup\", flipOrFlop(false), false);\n      })(keys, [37, 38, 39, 40, 32]);\n      Screen = {\n        left: 0.2,\n        right: 0.8,\n        top: 0.0,\n        bottom: 1.0,\n        width: 0.6,\n        height: 1.0\n      };\n      Score = (function() {\n        function Score() {\n          this.score = 0;\n          this.pool = 0;\n        }\n        Score.prototype.add = function(x) {\n          var _ref;\n          (_ref = this.pool) != null ? _ref : this.pool = x;\n          return this.pool += x;\n        };\n        Score.prototype.act = function() {\n          if (this.pool > 0) {\n            this.pool -= 1;\n            return this.score += 1;\n          }\n        };\n        Score.prototype.draw = function() {\n          var score;\n          score = (\"0000\" + this.score).substr(-4, 4);\n          return d.font(\"monospace\", 0.04, \"bold\").rgb(0x33, 0x33, 0x99).textAlign(\"right\").fillText(\"SCORE \" + score, [0.99, 0.01]);\n        };\n        return Score;\n      })();\n      Enemy = (function() {\n        Enemy.prototype.size = 0.04;\n        Enemy.prototype.accell = 0.01;\n        Enemy.prototype.damage = function() {\n          this.damaged = true;\n          this.life--;\n          if (!this.alive()) {\n            return score.add(10);\n          }\n        };\n        Enemy.prototype.alive = function() {\n          return this.life > 0;\n        };\n        Enemy.prototype.launchTypes = [\n          function() {\n            return new EnemyAmmo(this.p, [0.0, 0.005], this.hue);\n          }, function() {\n            var asp;\n            asp = player.p.sub(this.p).normalize(0.01);\n            return [new EnemyAmmo(this.p, asp.rotate(0.1), this.hue), new EnemyAmmo(this.p, asp.rotate(-0.1), this.hue)];\n          }, function() {\n            var asp;\n            asp = player.p.sub(this.p).normalize(0.01);\n            return new EnemyAmmo(this.p, asp, this.hue);\n          }\n        ];\n        function Enemy(p, life) {\n          this.p = p;\n          this.life = life != null ? life : 5;\n          this.type = (function(x) {\n            var a;\n            a = $R(0, 1).randf();\n            if ((0.0 <= a && a < 0.5)) {\n              return 0;\n            } else if ((0.5 <= a && a < 0.8)) {\n              return 1;\n            } else {\n              return 2;\n            }\n          })();\n          this.hue = [0.0, 0.25, 0.6][this.type];\n          this.launchType = this.launchTypes[this.type];\n        }\n        Enemy.prototype.move = function(sp) {\n          return this.p = this.p.add(sp.mul(this.accell));\n        };\n        Enemy.prototype.act = function() {\n          var _ref;\n          this.damaged = false;\n          (_ref = this.count) != null ? _ref : this.count = 0;\n          this.count++;\n          if (this.count % 20 === 0) {\n            ammos.push(this.launchType.call(this));\n          }\n          return this;\n        };\n        Enemy.prototype.draw = function() {\n          var s;\n          s = this.count < 4 ? this.count * 0.004 : 0;\n          return d.quads(Geo.rect(true).scale((this.size + this.damaged * (5 - this.life) * 0.0075 - s).arize(2)).translate(this.p)).blend(\"source-over\").alpha(0.4 + this.life * 0.15).hsv(this.hue, 0.1, 0.95).fill().hsv(this.hue, 0.3, 0.8).stroke();\n        };\n        return Enemy;\n      })();\n      Ammo = (function() {\n        function Ammo() {}\n        Ammo.prototype.valid = function() {\n          var _ref, _ref2;\n          return (-0.1 < (_ref = this.p[0]) && _ref < 1.1) && (-0.1 < (_ref2 = this.p[1]) && _ref2 < 1.1);\n        };\n        return Ammo;\n      })();\n      PlayerAmmo = (function() {\n        __extends(PlayerAmmo, Ammo);\n        PlayerAmmo.prototype.size = 0.02;\n        function PlayerAmmo() {\n          var _ref;\n          _ref = $A(arguments), this.p = _ref[0], this.sp = _ref[1];\n        }\n        PlayerAmmo.prototype.act = function() {\n          var _ref;\n          (_ref = this.count) != null ? _ref : this.count = 0;\n          this.count++;\n          return this.p = this.p.add(this.sp.mul(1 + this.count * 0.1));\n        };\n        PlayerAmmo.prototype.draw = function() {\n          return d.rgb(0x33, 0xcc, 0x66).alpha(0.5).lineWidth(0.005).quads(Geo.rect(true).rotate(this.count / 10).scale(this.size.arize(2)).translate(this.p)).stroke();\n        };\n        return PlayerAmmo;\n      })();\n      EnemyAmmo = (function() {\n        __extends(EnemyAmmo, Ammo);\n        EnemyAmmo.prototype.size = 0.015;\n        function EnemyAmmo() {\n          var buzzed, _ref;\n          _ref = $A(arguments), this.p = _ref[0], this.sp = _ref[1], this.hue = _ref[2];\n          buzzed = false;\n        }\n        EnemyAmmo.prototype.act = function() {\n          return this.p = this.p.add(this.sp);\n        };\n        EnemyAmmo.prototype.draw = function() {\n          return d.hsv(this.hue, 0.7, (this.buzzed ? 0.5 : 0.8)).alpha(0.8).lineWidth(0.01).quads(Geo.rect(true).scale(this.size.arize(2)).translate(this.p)).stroke();\n        };\n        return EnemyAmmo;\n      })();\n      Bit = (function() {\n        Bit.prototype.vissize = 0.015;\n        Bit.prototype.size = 0.045;\n        Bit.prototype.dist = 0.06;\n        function Bit(player, p, d) {\n          this.player = player;\n          this.p = p.clone();\n          this.d = d;\n          this.reserved = 0;\n          this.bound = true;\n        }\n        Bit.prototype.act = function() {\n          var _p, _ref;\n          (_ref = this.count) != null ? _ref : this.count = 0;\n          this.count++;\n          if (this.bound) {\n            _p = [0, this.dist].rotate((this.count / 6) + this.d.toRadian()).add(this.player.p);\n          } else {\n            _p = this.p;\n          }\n          this.p = this.p.add(_p).mul(0.5);\n          if (this.reserved !== 0) {\n            ammos.push(new PlayerAmmo(this.p, [Math.sin(this.count / 6) * 0.003, -0.02]));\n            return this.reserved--;\n          }\n        };\n        Bit.prototype.launch = function() {\n          this.player.launch();\n          return this.reserved += 1;\n        };\n        Bit.prototype.bindToggle = function() {\n          return this.bound ^= true;\n        };\n        Bit.prototype.draw = function() {\n          return d.quads(Geo.rect(true).rotate(this.count / 10).scale(this.vissize.arize(2)).translate(this.p)).blend(\"source-over\").alpha(0.35).lineWidth(0.008).rgb(0x33, 0x66, 0x99).stroke();\n        };\n        return Bit;\n      })();\n      Player = (function() {\n        Player.prototype.size = 0.01;\n        Player.prototype.sieldsize = 0.04;\n        Player.prototype.accell = 0.01;\n        function Player(p) {\n          this.p = p;\n        }\n        Player.prototype.move = function(sp) {\n          this.p = this.p.add(sp.mul(this.accell));\n          this.p[0] = (function(x) {\n            if (x < Screen.left) {\n              return Screen.left;\n            } else if (x > Screen.right) {\n              return Screen.right;\n            } else {\n              return x;\n            }\n          })(this.p[0]);\n          return this.p[1] = (function(x) {\n            if (x < Screen.top) {\n              return Screen.top;\n            } else if (x > Screen.bottom) {\n              return Screen.bottom;\n            } else {\n              return x;\n            }\n          })(this.p[1]);\n        };\n        Player.prototype.launch = function() {\n          var _ref;\n          (_ref = this.reserved) != null ? _ref : this.reserved = 0;\n          this.reserved++;\n          return ammos.push(new PlayerAmmo(this.p, [0, -0.01]));\n        };\n        Player.prototype.kill = function() {\n          return this.killed = true;\n        };\n        Player.prototype.act = function() {\n          var _ref;\n          (_ref = this.count) != null ? _ref : this.count = 0;\n          this.count++;\n          if (this.count % 4 === 0) {\n            ammos.push(new PlayerAmmo(this.p, [0, -0.01]));\n          }\n          if (this.reserved > 0) {\n            ammos.push(new PlayerAmmo(this.p, [0, -0.01]));\n            this.reserved--;\n          }\n          return this;\n        };\n        Player.prototype.draw = function() {\n          return d.quads(Geo.rect(true).rotate(this.count / 10).scale(this.sieldsize.arize(2)).translate(this.p)).blend(\"source-over\").alpha(0.3).rgb(0xaa, 0xff, 0xff).fill().alpha(0.9).rgb(0x77, 0x77, 0xcc).stroke().alpha(0.9).rgb(0xff, 0x99, 0x99).quads(Geo.rect(true).scale(this.size.arize(2)).translate(this.p)).fill();\n        };\n        return Player;\n      })();\n      player = new Player([0.5, 0.8]);\n      bits = [0, 1, 2].map(function(x) {\n        return new Bit(player, player.p, x / 3);\n      });\n      ammos = [];\n      enemies = [];\n      score = new Score();\n      return (function(c, lv) {\n        var collisionTest, rand, _i, _results;\n        if (lv == null) {\n          lv = 0;\n        }\n        if (c % (150 - lv) === 0) {\n          if (enemies.length === 0) {\n            score.add(lv * 3);\n          }\n          (3 + ~~(lv / 4)).times(function(x) {\n            return enemies.push(new Enemy([$R(Screen.left, Screen.right).randf(), $R(0.03, 0.1).randf()]));\n          });\n          lv++;\n        }\n        d.blend(\"copy\").alpha(1).rgb(0xea, 0xe9, 0xff).fillBack();\n        rand = random();\n        (function() {\n          _results = [];\n          for (_i = 0; _i <= 100; _i++){ _results.push(_i); }\n          return _results;\n        }).apply(this, arguments).each(function(x) {\n          var p, s;\n          p = [(x % 10 * Screen.width) * 0.1 + Screen.left, rand() * 2.5 - 0.25];\n          s = (~(x * x / 1000.0) / 100) + 0.1;\n          s = x / 800 + 0.02;\n          p[1] += c / 10 * s + 0.15;\n          p[1] %= 2.0;\n          p[1] -= 0.5;\n          return d.quads(Geo.rect(true).scale(s.arize(2)).translate(p)).blend(\"source-over\").alpha(0.15).rgb(0xaa, 0xaa, 0xff).fill().lineWidth(0.01).stroke();\n        });\n        if (keys[37]) {\n          player.move([-1, 0]);\n        }\n        if (keys[38]) {\n          player.move([0, -1]);\n        }\n        if (keys[39]) {\n          player.move([1, 0]);\n        }\n        if (keys[40]) {\n          player.move([0, 1]);\n        }\n        if (keys[32]) {\n          bits.each(function(x) {\n            return x.bindToggle();\n          });\n        }\n        keys[32] = false;\n        enemies = enemies.select(function(x) {\n          return x.alive();\n        });\n        [player, enemies, bits].shallowFlatten().each(function(x) {\n          return x.act();\n        });\n        collisionTest = function(lhs, rhs) {\n          return lhs.p.distance(rhs.p) < lhs.size + rhs.size;\n        };\n        ammos = ammos.flatten().select(function(ammo) {\n          var enemy;\n          ammo.act();\n          if (!ammo.valid()) {\n            return false;\n          } else if (ammo instanceof EnemyAmmo) {\n            bits.each(function(bit) {\n              if (collisionTest(ammo, bit)) {\n                if (!ammo.buzzed) {\n                  bit.launch();\n                }\n                if (!ammo.buzzed) {\n                  score.add(1);\n                }\n                return ammo.buzzed = true;\n              }\n            });\n            if (collisionTest(ammo, player)) {\n              player.kill();\n            }\n            return true;\n          } else if (ammo instanceof PlayerAmmo) {\n            enemy = enemies.find(function(enemy) {\n              return collisionTest(ammo, enemy);\n            });\n            if (enemy != null) {\n              enemy.damage();\n            }\n            return !enemy;\n          }\n        }).map(function(ammo) {\n          ammo.draw();\n          return ammo;\n        });\n        [player, enemies, bits].shallowFlatten().each(function(x) {\n          return x.draw();\n        });\n        d.alpha(0.8).rgb(0xbb, 0xcc, 0xff).quads(Geo.rect(false).scale([Screen.left, Screen.height])).fill().quads(Geo.rect(false).scale([Screen.left, Screen.height]).translate([Screen.right, Screen.top])).fill();\n        score.act();\n        score.draw();\n        if (!player.killed) {\n          return window.setTimeout(arguments.callee.curry(c + 1, lv), 33);\n        } else {\n          if (confirm(\"Game is over. (Score \" + score.score + \")\\nContinue?\")) {\n            return main();\n          }\n        }\n      })(0);\n    });\n    return main();\n  };\n}).call(this);\n\n"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/r/H/L/rHLd_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/r/H/L/rHLd.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/r/H/L/rHLd_100.jpg"},"description_html":"CoffeeScript+自作ライブラリ使用してアブストラクトシューティングゲーム試作。<br />\n※Chrome or Safariを強く推奨<br />\n<br />\n周りぐるぐるしてる奴は敵弾に触れると打ち返してくれます。<br />\n周りぐるぐるしてる奴は\"Space Key\"で切り離せます。<br />\n<br />\nCoffeeScript所感<br />\n・functionって書かなくて良いのが好印象<br />\n・functionって書かなくて良いのが好印象<br />\n・functionって書かなくて良いのが好印象","parent":{"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/g/A/o/gAoN_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/g/A/o/gAoN.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/g/A/o/gAoN_100.jpg"},"modified_date":"2011-03-10 16:26:19","uid":"gAoN","created_date":"2011-03-10 15:36:25","path":"gAoN","description":"JSのコード部分に前後を/*と*/でくくったCoffeeScriptを記述するとresultに実行結果、codeにコンパイル後のJSを出力します。\n（//forked fromとかはあっても大丈夫です）","statistic":{"forked":"74","favorite":"8","pageview":"124260"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/4/f/4/0/4f404b86e6ba1fbb2ea71bed4f9241a1b840bd88_100.jpg","name":"kyo_ago"},"url":"http://jsdo.it/kyo_ago/gAoN","title":"CoffeeScript出来るかな"},"modified_date":"2011-04-24 23:16:07","uid":"rHLd","created_date":"2011-04-24 21:55:11","path":"rHLd","description":"CoffeeScript+自作ライブラリ使用してアブストラクトシューティングゲーム試作。\n※Chrome or Safariを強く推奨\n\n周りぐるぐるしてる奴は敵弾に触れると打ち返してくれます。\n周りぐるぐるしてる奴は\"Space Key\"で切り離せます。\n\nCoffeeScript所感\n・functionって書かなくて良いのが好印象\n・functionって書かなくて良いのが好印象\n・functionって書かなくて良いのが好印象","statistic":{"forked":"11","favorite":"10","pageview":"8217"},"url":"http://jsdo.it/crispy/rHLd","user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"title":"Shooting game in CoffeeScript forked from: CoffeeScript出来るかな"}