{"source":{"css":"body { background-color: #000; margin: 0px; overflow: hidden; }\n","html":"<canvas id='world'></canvas>","lisence":"MIT","js":"// Generated by CoffeeScript 1.3.3\n(function() {\n  var __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  window.onload = function() {\n    var Cpu, Hand, Judge, Judgement, Phase, PhaseFighting, PhaseInitialize, PhaseOpening, Player, Pose, Stage, createTexture, d, main, phase, prevPhase;\n    (function() {\n      var lastTime, org_setTimeout;\n      lastTime = 0;\n      org_setTimeout = window.setTimeout;\n      return window.setTimeout = function(func, wait) {\n        var realWait;\n        realWait = lastTime ? wait : wait - (new Date() - lastTime);\n        if (realWait <= 0) {\n          realWait = 1;\n        }\n        lastTime = +new Date();\n        return org_setTimeout(func, realWait);\n      };\n    })();\n    d = new DCore();\n    createTexture = function(src, width, height) {\n      var image;\n      image = new Image;\n      image.src = src;\n      image.width = width;\n      image.height = height;\n      return image;\n    };\n    Stage = (function() {\n\n      function Stage() {\n        this.camp = [0.1, 0];\n        this.camw = 1;\n        this.mTex = this.genMountainTexture();\n      }\n\n      Stage.prototype.genMountainTexture = function() {\n        var mountain, sd, z;\n        mountain = $R(0, 127).map(function(x) {\n          return [x / 127, 0.9];\n        });\n        z = 0.5;\n        64..times(function(i) {\n          z = (z + pelinNoise(6)) / 2;\n          mountain[i + 0][1] -= z;\n          return mountain[i + 64][1] -= z;\n        });\n        mountain[0][1] = mountain[63][1] = mountain[64][1] = mountain[127][1] = 0.7;\n        mountain.push([1, 1]);\n        mountain.push([0, 1]);\n        sd = d.subTexture(512, 256);\n        sd.rgb([0x11, 0x22, 0x66]).quads(mountain).fill();\n        return sd;\n      };\n\n      Stage.prototype.delegateDraw = function(absolute, fn) {\n        var f, s;\n        if (absolute) {\n          s = [0, 0];\n        } else {\n          s = this.camp.scale(-1, 1);\n        }\n        if (this.shockCount > 0) {\n          f = $R(-1, 1).randf() * this.shockCount;\n          s = s.add([$R(-1, 1).randf() * this.shockCount * 0.01, $R(-1, 1).randf() * this.shockCount * 0.01]);\n        }\n        return d.save().translate(s).tap(fn).restore();\n      };\n\n      Stage.prototype.shock = function() {\n        return this.shockCount = 4;\n      };\n\n      Stage.prototype.damaged = function() {\n        return this.damagedCount = 2;\n      };\n\n      Stage.prototype.captureHands = function(hand1, hand2) {\n        this.hand1 = hand1;\n        return this.hand2 = hand2;\n      };\n\n      Stage.prototype.reset = function() {\n        return this.camp[0] = (this.hand1.p[0] + this.hand2.p[0]) / 2 - this.camw / 2;\n      };\n\n      Stage.prototype.act = function() {\n        var _this = this;\n        [this.hand1.p[0], this.hand2.p[0]].each(function(x) {\n          if (x - 0.2 < _this.camp[0]) {\n            _this.camp[0] = (x - 0.2 + _this.camp[0]) / 2;\n          }\n          if (x + 0.2 > _this.camp[0] + _this.camw) {\n            return _this.camp[0] = (x + 0.2 + _this.camp[0] - _this.camw) / 2;\n          }\n        });\n        this.shockCount--;\n        return this.damagedCount--;\n      };\n\n      Stage.prototype.draw = function() {\n        var _this = this;\n        return this.delegateDraw(true, function() {\n          var rnd, x;\n          d.gradient([0, 0], [0, 1], [[0, [0x33, 0x33, 0x66]], [1, [0x44, 0x44, 0xaa]]]).rect([0, 0.0], [1, 1.0]).fill();\n          rnd = randomGen();\n          300..times(function(x) {\n            var p, s, v;\n            x = [4 * rnd() - _this.camp[0] + 65536];\n            x = x % 4;\n            p = [x, rnd() * 0.9];\n            v = 1 - p[1] + rnd() * 0.3;\n            s = rnd() * 0.003 + 0.002;\n            return d.rgb(v * 0xff, v * 0xff, v * 0x99).circle(p, s).fill();\n          });\n          x = (_this.camp[0] * 0.1 + 12345) % 0.5 + 0.25;\n          d.blend(\"source-over\").alpha(0.3).drawImage(_this.mTex, [x, 0.5], [0.2, 0.5], [0, 0.5], [1, 0.4]);\n          x = (_this.camp[0] * 0.075 + 12345.1) % 0.5 + 0.25;\n          d.blend(\"source-over\").alpha(0.5).drawImage(_this.mTex, [x, 0.5], [0.2, 0.5], [0, 0.5], [1, 0.5]);\n          x = (_this.camp[0] * 0.05 + 12345.2) % 0.5 + 0.25;\n          d.blend(\"source-over\").alpha(1.0).drawImage(_this.mTex, [x, 0.4], [0.2, 0.6], [0, 0.5], [1, 0.6]).gradient([0, 0.9], [0, 1], [[0, [0x33, 0x33, 0x44]], [1, [0x77, 0x66, 0x99]]]).rect([0, 0.9], [1, 0.1]).fill();\n          if (_this.damagedCount > 0) {\n            return d.rgb(0xff, 0x00, 0x00).fillBack();\n          }\n        });\n      };\n\n      return Stage;\n\n    })();\n    Pose = {\n      Rock: 0,\n      Scissors: 1,\n      Paper: 2,\n      Size: 3\n    };\n    Hand = (function() {\n\n      function Hand(x, direction) {\n        this.life = 256;\n        this.s = [0.15, 0.15];\n        this.p = [x, 0.98 - this.s[1]];\n        this.direction = direction;\n        this.sp = 0.01;\n        this.dasheSp = 0.00;\n        this.knockBackSp = 0.00;\n        this.pose = Pose.Rock;\n        this.reflectCnt = 0;\n        this.images = [createTexture(\"http://jsrun.it/assets/a/H/C/r/aHCrM.png\", 169, 169), createTexture(\"http://jsrun.it/assets/a/r/G/j/arGjf.png\", 166, 195), createTexture(\"http://jsrun.it/assets/5/R/8/k/5R8kA.png\", 180, 180)];\n        this.willTo(\"nop\");\n        this.knockOutCnt = 0;\n      }\n\n      Hand.prototype.captureJudgement = function(judgement) {\n        return this.judgement = judgement;\n      };\n\n      Hand.prototype.captureEnemy = function(enemy) {\n        return this.enemy = enemy;\n      };\n\n      Hand.prototype.damage = function() {\n        var ss;\n        ss = 2;\n        if (this.enemy.dasheSp > 0.002) {\n          ss *= 2.0;\n        }\n        if (this.dasheSp > 0.002) {\n          ss *= 4.0;\n        }\n        return this.life -= 8 * ss;\n      };\n\n      Hand.prototype.act = function() {\n        if (this.life < 0 && this.reflection !== \"\") {\n          this.reflectTo(\"knockOut\", 10);\n        }\n        if (this.enemy < 0 && this.reflectTo !== \"\") {\n          this.reflectTo(\"nop\", 3);\n        }\n        this.dasheSp *= 0.7;\n        this.knockBackSp *= 0.7;\n        this.reflectCnt--;\n        if (this.reflectCnt > 0) {\n          Hand.prototype[this.reflection].apply(this, null);\n        } else {\n          Hand.prototype[this.will].apply(this, null);\n        }\n        this.p[0] += this.dasheSp;\n        return this.p[0] += this.knockBackSp;\n      };\n\n      Hand.prototype.reborn = function() {\n        this.p[0] = this.enemy.p[0] + this.enemy.direction * 0.7;\n        this.p[1] = 0.08 - 0.15;\n        this.reflectTo(\"reborning\", 10);\n        return this.heal();\n      };\n\n      Hand.prototype.heal = function() {\n        this.life = 256;\n        return this.knockOutCnt = 0;\n      };\n\n      Hand.prototype.reborning = function() {\n        return this.p[1] += 0.1;\n      };\n\n      Hand.prototype.willTo = function(will) {\n        return this.will = will;\n      };\n\n      Hand.prototype.reflectTo = function(reflection, reflectCnt) {\n        this.reflection = reflection;\n        return this.reflectCnt = reflectCnt;\n      };\n\n      Hand.prototype.transform = function(pose) {\n        return this.pose = pose;\n      };\n\n      Hand.prototype.nop = function() {};\n\n      Hand.prototype.dashe = function() {\n        if (this.dasheSp.abs() < 0.01) {\n          return this.dasheSp += 0.08 * this.direction;\n        }\n      };\n\n      Hand.prototype.backSteppo = function() {\n        if (this.dasheSp.abs() < 0.01) {\n          return this.dasheSp -= 0.04 * this.direction;\n        }\n      };\n\n      Hand.prototype.moveBack = function() {\n        return this.p[0] += -this.sp * this.direction;\n      };\n\n      Hand.prototype.moveFront = function() {\n        return this.p[0] += this.sp * this.direction;\n      };\n\n      Hand.prototype.weakKnockBack = function() {\n        this.knockBackSp = -0.05 * this.direction;\n        return this.reflectTo(\"nop\", 3);\n      };\n\n      Hand.prototype.knockBack = function() {\n        this.knockBackSp = -0.1 * this.direction;\n        return this.reflectTo(\"nop\", 3);\n      };\n\n      Hand.prototype.knockOut = function() {\n        this.p[0] -= 0.05 * this.direction;\n        this.p[1] -= 0.05;\n        return this.knockOutCnt++;\n      };\n\n      Hand.prototype.draw = function() {\n        return d.drawImage(this.images[this.pose], [0, 0], [1, 1], this.p, this.s);\n      };\n\n      return Hand;\n\n    })();\n    Judge = {\n      Draw: 0,\n      Lose: 1,\n      Win: 2\n    };\n    Judgement = (function() {\n\n      function Judgement() {\n        this.se_lose = new Audio(\"http://dl.dropbox.com/u/3589634/resource/se/se_lose.ogg\");\n        this.se_draw = new Audio(\"http://dl.dropbox.com/u/3589634/resource/se/se_draw.ogg\");\n        this.se_win = new Audio(\"http://dl.dropbox.com/u/3589634/resource/se/se_win.ogg\");\n      }\n\n      Judgement.prototype.playOgg = function(audio) {\n        if (audio.currentTime) {\n          audio.pause();\n          audio.currentTime = 0;\n        }\n        return audio.play();\n      };\n\n      Judgement.prototype.judge = function(self, enemy) {\n        return (self.pose - enemy.pose + Pose.Size) % Pose.Size;\n      };\n\n      Judgement.prototype.tellMeHowToWin = function(enemy) {\n        return (enemy.pose + 2 + Pose.Size) % Pose.Size;\n      };\n\n      Judgement.prototype.tellMeHowToLose = function(enemy) {\n        return (enemy.pose + 1 + Pose.Size) % Pose.Size;\n      };\n\n      Judgement.prototype.captureHands = function(hand1, hand2) {\n        this.hand1 = hand1;\n        return this.hand2 = hand2;\n      };\n\n      Judgement.prototype.captureStage = function(stage) {\n        return this.stage = stage;\n      };\n\n      Judgement.prototype.hitTest = function() {\n        var result, signBase;\n        if ((this.hand1.p[0] - this.hand2.p[0]).abs() < (this.hand1.s[0] + this.hand2.s[1]) / 2 / 2) {\n          signBase = (this.hand1.p[0] - this.hand2.p[0]).sign();\n          result = this.judge(this.hand1, this.hand2);\n          if (result === Judge.Draw) {\n            this.hand1.knockBack();\n            this.hand2.knockBack();\n            return this.playOgg(this.se_draw);\n          } else if (result === Judge.Lose) {\n            this.hand1.knockBack();\n            this.hand1.damage();\n            this.hand2.weakKnockBack();\n            this.stage.shock();\n            this.stage.damaged();\n            return this.playOgg(this.se_lose);\n          } else if (result === Judge.Win) {\n            this.hand1.weakKnockBack();\n            this.hand2.knockBack();\n            this.hand2.damage();\n            this.stage.shock();\n            return this.playOgg(this.se_win);\n          }\n        }\n      };\n\n      return Judgement;\n\n    })();\n    Player = (function(_super) {\n\n      __extends(Player, _super);\n\n      function Player() {\n        Player.__super__.constructor.call(this, 0.1, 1);\n      }\n\n      return Player;\n\n    })(Hand);\n    Cpu = (function(_super) {\n\n      __extends(Cpu, _super);\n\n      function Cpu() {\n        this.willTo(\"moveFront\");\n        this.nextDecition = 0;\n        this.setParam();\n        Cpu.__super__.constructor.call(this, 0.7, -1);\n      }\n\n      Cpu.prototype.setParam = function(clock, p1, p2, p3) {\n        if (clock == null) {\n          clock = 12;\n        }\n        if (p1 == null) {\n          p1 = 5;\n        }\n        if (p2 == null) {\n          p2 = 5;\n        }\n        if (p3 == null) {\n          p3 = 0.1;\n        }\n        this.clock = 12;\n        this.p1 = p1;\n        this.p2 = p2;\n        return this.p3 = p3;\n      };\n\n      Cpu.prototype.willTo = function(will) {\n        return Cpu.__super__.willTo.call(this, will);\n      };\n\n      Cpu.prototype.makeDecision = function() {\n        var distance, simulate;\n        simulate = this.judgement.judge(this, this.enemy);\n        if (simulate === Judge.Lose) {\n          if (!(this.clock * this.p1 * 1..rand())) {\n            this.pose = this.judgement.tellMeHowToWin(this.enemy);\n          }\n        }\n        distance = (this.enemy.p[0] - this.p[0]).abs();\n        if (distance > 0.8) {\n          if (1..randf() < 0.5) {\n            this.willTo(\"dashe\");\n          }\n        } else if (distance.abs() > 0.3) {\n          if (1..randf() < 0.2) {\n            this.willTo(\"moveBack\");\n          } else {\n            this.willTo(\"moveFront\");\n          }\n        } else {\n          if (1..randf() < this.p3) {\n            this.willTo(\"dashe\");\n          } else {\n            this.willTo(\"moveBack\");\n            if (1..randf() < this.p2) {\n              this.pose = this.judgement.tellMeHowToLose(this.enemy);\n            }\n          }\n        }\n        if (1..randf() < 0.1) {\n          this.willTo(\"moveBack moveFront dashe moveBack nop\".split(\" \").randomSelect());\n        }\n        if (1..randf() < 0.1) {\n          return this.transform([Pose.Rock, Pose.Scissors, Pose.Paper].randomSelect());\n        }\n      };\n\n      Cpu.prototype.act = function() {\n        if (this.nextDecition <= 0) {\n          this.makeDecision();\n          this.nextDecition += this.clock * $R(0, 2).rand();\n        }\n        this.nextDecition--;\n        if (this.p[0] < this.enemy.p[0]) {\n          this.p[0] = this.enemy.p[0] + 0.01;\n        }\n        return Cpu.__super__.act.apply(this, arguments);\n      };\n\n      return Cpu;\n\n    })(Hand);\n    Phase = (function() {\n\n      function Phase() {}\n\n      Phase.prototype.activateFrom = function(from) {\n        this.kb = from.kb;\n        this.judgement = from.judgement;\n        this.player = from.player;\n        this.cpu = from.cpu;\n        this.stage = from.stage;\n        return this.lv = from.lv;\n      };\n\n      return Phase;\n\n    })();\n    PhaseInitialize = (function(_super) {\n\n      __extends(PhaseInitialize, _super);\n\n      function PhaseInitialize() {\n        return PhaseInitialize.__super__.constructor.apply(this, arguments);\n      }\n\n      PhaseInitialize.prototype.initialize = function() {\n        var _this = this;\n        this.kb = new Keyboard();\n        '37 39 X Y Z V'.split(' ').each(function(x) {\n          return _this.kb.at(x).enablePrevent();\n        });\n        this.judgement = new Judgement();\n        this.player = new Player();\n        this.cpu = new Cpu();\n        this.stage = new Stage();\n        this.player.transform(Pose.Rock);\n        this.cpu.transform(Pose.Rock);\n        this.judgement.captureHands(this.player, this.cpu);\n        this.judgement.captureStage(this.stage);\n        this.player.captureJudgement(this.judgement);\n        this.player.captureEnemy(this.cpu);\n        this.cpu.captureJudgement(this.judgement);\n        this.cpu.captureEnemy(this.player);\n        this.stage.captureHands(this.player, this.cpu);\n        return this.lv = 1;\n      };\n\n      return PhaseInitialize;\n\n    })(Phase);\n    PhaseOpening = (function(_super) {\n\n      __extends(PhaseOpening, _super);\n\n      function PhaseOpening() {\n        return PhaseOpening.__super__.constructor.apply(this, arguments);\n      }\n\n      PhaseOpening.prototype.initialize = function() {\n        var ps;\n        this.stage.reset();\n        ps = [[5, 2, 0.1], [8, 2, 0.1], [5, 4, 0.1], [5, 2, 0.2]].randomSelect();\n        this.cpu.setParam(128 / (this.lv + 8), ps[0], ps[1], ps[2]);\n        this.count = 0;\n        this.maxFrame = 40;\n        return this.prefix = \"\";\n      };\n\n      PhaseOpening.prototype.main = function() {\n        var len,\n          _this = this;\n        this.kb.flush();\n        this.stage.act();\n        this.stage.draw();\n        this.player.willTo(\"nop\");\n        if (this.kb.at(37).pressing) {\n          this.player.willTo(\"moveBack\");\n        }\n        if (this.kb.at(39).pressing) {\n          this.player.willTo(\"moveFront\");\n        }\n        this.player.act();\n        this.cpu.act();\n        this.stage.delegateDraw(false, function() {\n          _this.player.draw();\n          return _this.cpu.draw();\n        });\n        this.count++;\n        d.rgb(0x00, 0x00, 0x00).alpha(0.5).blend(\"source-over\").rect([0, 0.4], [1, 0.2]).fill();\n        d.alpha(1).rgb(0xff, 0xff, 0xff).textBaseline(\"middle\").textAlign(\"center\").font(\"cursive\", 0.2, \"italic\").fillText(\"VS - \" + \"LV.\" + this.lv, [0.5, 0.5]);\n        len = this.count / this.maxFrame;\n        d.alpha(0.5).rgb(0xff, 0x00, 0x00).rect([1 - len, 0.4], [len, 0.01]).fill().rect([0, 0.6], [len, 0.01]).fill();\n        d.alpha(1);\n        if (this.count > this.maxFrame) {\n          return new PhaseFighting();\n        }\n        return this;\n      };\n\n      return PhaseOpening;\n\n    })(Phase);\n    PhaseFighting = (function(_super) {\n\n      __extends(PhaseFighting, _super);\n\n      function PhaseFighting() {\n        return PhaseFighting.__super__.constructor.apply(this, arguments);\n      }\n\n      PhaseFighting.prototype.initialize = function() {};\n\n      PhaseFighting.prototype.main = function() {\n        var _this = this;\n        this.kb.flush();\n        this.stage.act();\n        this.stage.draw();\n        this.player.willTo(\"nop\");\n        if (this.kb.at(37).pressing) {\n          if (this.kb.at('V').downed) {\n            this.player.willTo(\"backSteppo\");\n          } else {\n            this.player.willTo(\"moveBack\");\n          }\n        }\n        if (this.kb.at(39).pressing) {\n          if (this.kb.at('V').downed) {\n            this.player.willTo(\"dashe\");\n          } else {\n            this.player.willTo(\"moveFront\");\n          }\n        }\n        if (this.kb.at('Z').downed) {\n          this.player.transform(Pose.Rock);\n        }\n        if (this.kb.at('X').downed) {\n          this.player.transform(Pose.Scissors);\n        }\n        if (this.kb.at('C').downed) {\n          this.player.transform(Pose.Paper);\n        }\n        this.player.act();\n        this.cpu.act();\n        this.stage.delegateDraw(false, function() {\n          _this.player.draw();\n          return _this.cpu.draw();\n        });\n        this.judgement.hitTest();\n        this.stage.delegateDraw(true, function() {\n          d.blend(\"source-over\").alpha(0.8).gradient([0, 0], [1, 0], [[0, [0xff, 0x00, 0x00]], [1, [0x99, 0x99, 0xff]]]);\n          d.rect([0, 0.02], [_this.player.life / 256, 0.01]).fill();\n          d.rect([0.0, 0.05], [_this.cpu.life / 256, 0.01]).fill();\n          return d.blend(\"source-over\").alpha(1.0);\n        });\n        if (this.cpu.knockOutCnt > 45) {\n          this.cpu.reborn();\n          this.player.heal();\n          this.cpu.heal();\n          this.lv++;\n          return new PhaseOpening();\n        } else if (this.player.knockOutCnt > 45) {\n          this.player.reborn();\n          this.player.heal();\n          this.cpu.heal();\n          this.lv -= 3;\n          if (this.lv <= 0) {\n            this.lv = 1;\n          }\n          return new PhaseOpening();\n        } else {\n          return this;\n        }\n      };\n\n      return PhaseFighting;\n\n    })(Phase);\n    prevPhase = new PhaseInitialize();\n    prevPhase.initialize();\n    phase = new PhaseOpening();\n    main = function(c) {\n      if (c == null) {\n        c = 0;\n      }\n      if (phase !== prevPhase) {\n        phase.activateFrom(prevPhase);\n        phase.initialize();\n      }\n      prevPhase = phase;\n      phase = phase.main();\n      return setTimeout(arguments.callee.curry(c + 1), 33);\n    };\n    return main();\n  };\n\n}).call(this);\n","coffeescript":"window.onload = ->\n\n\t# install pseude fps control\n\t(() ->\n\t\tlastTime = 0\n\t\torg_setTimeout = window.setTimeout\n\t\twindow.setTimeout = (func, wait) ->\n\t\t\trealWait = if lastTime then wait else wait - (new Date() - lastTime)\n\t\t\trealWait = 1 if realWait <= 0\n\t\t\tlastTime = +new Date()\n\t\t\torg_setTimeout(func, realWait)\n\t)()\n\n\t# create my lib\n\td = new DCore()\n\n\t# create texture (a wraper function for load image):w\n\tcreateTexture = (src, width, height) ->\n\t\timage = new Image\n\t\timage.src = src\n\t\timage.width = width\n\t\timage.height = height\n\t\timage\n\n\t# stage\n\tclass Stage\n\t\tconstructor: ->\n\t\t\t@camp = [0.1, 0]\n\t\t\t@camw = 1\n\t\t\t@mTex = @genMountainTexture()\n\n\t\tgenMountainTexture: ->\n\n\t\t\tmountain = $R(0, 127).map (x) ->\n\t\t\t\treturn [x / 127, 0.9]\n\n\t\t\tz = 0.5\n\t\t\t64 .times (i) ->\n\t\t\t\tz = (z + pelinNoise(6)) / 2\n\t\t\t\tmountain[i +  0][1] -= z\n\t\t\t\tmountain[i + 64][1] -= z\n\n\t\t\tmountain[  0][1] = \n\t\t\tmountain[ 63][1] = \n\t\t\tmountain[ 64][1] = \n\t\t\tmountain[127][1] = 0.7\n\t\t\tmountain.push([1, 1])\n\t\t\tmountain.push([0, 1])\n\n\t\t\tsd = d.subTexture(512, 256)\n\t\t\tsd\n\t\t\t\t.rgb([0x11, 0x22, 0x66])\n\t\t\t\t.quads(mountain)\n\t\t\t\t.fill()\n\n\t\t\tsd\n\n\t\tdelegateDraw: (absolute, fn) ->\n\t\t\tif absolute\n\t\t\t\ts = [0, 0]\n\t\t\telse\n\t\t\t\ts = @camp.scale(-1, 1)\n\n\t\t\tif @shockCount > 0\n\t\t\t\tf = $R(-1, 1).randf() * @shockCount\n\t\t\t\ts = s.add([$R(-1, 1).randf() * @shockCount * 0.01, $R(-1, 1).randf() * @shockCount * 0.01])\n\n\t\t\td\n\t\t\t .save()\n\t\t\t .translate(s)\n\t\t\t .tap(fn)\n\t\t\t .restore()\n\t\t# shake screen\n\t\tshock: ->\n\t\t\t@shockCount = 4\n\t\t# damaged (screen background fill with red)\n\t\tdamaged: ->\n\t\t\t@damagedCount = 2\n\t\tcaptureHands: (hand1, hand2) ->\n\t\t\t@hand1 = hand1\n\t\t\t@hand2 = hand2\n\t\treset: ->\n\t\t\t@camp[0] = (@hand1.p[0] + @hand2.p[0]) / 2 - @camw / 2\n\t\tact: ->\n\t\t\t# adjust camera position\n\t\t\t[@hand1.p[0], @hand2.p[0]].each (x) =>\n\t\t\t\tif x - 0.2 < @camp[0]\n\t\t\t\t\t@camp[0] = (x - 0.2 + @camp[0]) / 2\n\t\t\t\tif x + 0.2 > @camp[0] + @camw\n\t\t\t\t\t@camp[0] = (x + 0.2 + @camp[0] - @camw) / 2\n\t\t\t@shockCount--\n\t\t\t@damagedCount--\n\t\tdraw: ->\n\t\t\t@delegateDraw true, () =>\n\n\t\t\t\t# back\n\t\t\t\td\n\t\t\t\t .gradient([0, 0], [0, 1], [\n\t\t\t\t\t\t[0,  [0x33, 0x33, 0x66]],\n\t\t\t\t\t\t[1,  [0x44, 0x44, 0xaa]]\n\t\t\t\t\t])\n\t\t\t\t .rect([0, 0.0], [1, 1.0])\n\t\t\t\t .fill()\n\n\t\t\t\t# stars\n\t\t\t\trnd = randomGen()\n\t\t\t\t300 .times (x) =>\n\t\t\t\t\tx = [4 * rnd() - @camp[0] + 65536]\n\t\t\t\t\tx = x % 4\n\t\t\t\t\tp = [x, rnd() * 0.9]\n\t\t\t\t\tv = 1 - p[1] + rnd() * 0.3\n\t\t\t\t\ts = rnd() * 0.003 + 0.002\n\t\t\t\t\td\n\t\t\t\t\t .rgb(v * 0xff, v * 0xff, v * 0x99)\n\t\t\t\t\t .circle(p, s)\n\t\t\t\t\t .fill()\n\n\t\t\t\t# draw far mountain\n\t\t\t\tx = (@camp[0] * 0.1 + 12345) % 0.5 + 0.25\n\t\t\t\td\n\t\t\t\t .blend(\"source-over\")\n\t\t\t\t .alpha(0.3)\n\t\t\t\t .drawImage(@mTex, \n\t\t\t\t  [x, 0.5], [0.2, 0.5],\n\t\t\t\t\t[0, 0.5], [1, 0.4]\n\t\t\t\t )\n\n\t\t\t\t# draw middle range mountain\n\t\t\t\tx = (@camp[0] * 0.075 + 12345.1) % 0.5 + 0.25\n\t\t\t\td\n\t\t\t\t .blend(\"source-over\")\n\t\t\t\t .alpha(0.5)\n\t\t\t\t .drawImage(@mTex, \n\t\t\t\t  [x, 0.5], [0.2, 0.5],\n\t\t\t\t\t[0, 0.5], [1, 0.5]\n\t\t\t\t )\n\n\t\t\t\t# draw near mountain\n\t\t\t\tx = (@camp[0] * 0.05 + 12345.2) % 0.5 + 0.25\n\t\t\t\td\n\t\t\t\t .blend(\"source-over\")\n\t\t\t\t .alpha(1.0)\n\t\t\t\t .drawImage(@mTex, \n\t\t\t\t  [x, 0.4], [0.2, 0.6],\n\t\t\t\t\t[0, 0.5], [1, 0.6]\n\t\t\t\t )\n\n\t\t\t\t# floor\n\t\t\t\t .gradient([0, 0.9], [0, 1], [\n\t\t\t\t\t\t[0,  [0x33, 0x33, 0x44]],\n\t\t\t\t\t\t[1,  [0x77, 0x66, 0x99]]\n\t\t\t\t\t])\n\t\t\t\t .rect([0, 0.9], [1, 0.1])\n\t\t\t\t .fill()\n\n\t\t\t\t# fill back with red when damaged\n\t\t\t\tif @damagedCount > 0\n\t\t\t\t\td\n\t\t\t\t\t .rgb(0xff, 0x00, 0x00)\n\t\t\t\t\t .fillBack()\n\n\n\t# Pose\n\tPose =\n\t\tRock: 0\n\t\tScissors: 1\n\t\tPaper: 2\n\t\tSize: 3\n\n  # base class for Player and Cpu\n\tclass Hand\n\t\tconstructor: (x, direction) ->\n\t\t\t@life = 256\n\t\t\t@s = [0.15, 0.15]\n\t\t\t@p = [x, 0.98 - @s[1]]\n\t\t\t# direction(-1: left, 1:right)\n\t\t\t@direction = direction\n\t\t\t# normal speed (\n\t\t\t@sp = 0.01\n\t\t\t# dashe speed\n\t\t\t@dasheSp = 0.00\n\t\t\t# knockback speed\n\t\t\t@knockBackSp = 0.00\n\t\t\t# pose\n\t\t\t@pose = Pose.Rock\n\t\t\t# reflection count\n\t\t\t@reflectCnt = 0\n\t\t\t# load images\n\t\t\t@images = [\n\t\t\t\tcreateTexture(\"http://jsrun.it/assets/a/H/C/r/aHCrM.png\", 169, 169),\n\t\t\t\tcreateTexture(\"http://jsrun.it/assets/a/r/G/j/arGjf.png\", 166, 195),\n\t\t\t\tcreateTexture(\"http://jsrun.it/assets/5/R/8/k/5R8kA.png\", 180, 180)\n\t\t\t]\n\t\t\t# set default will\n\t\t\t@willTo(\"nop\")\n\t\t\t# death count\n\t\t\t@knockOutCnt = 0\n\t\tcaptureJudgement: (judgement) ->\n\t\t\t@judgement = judgement\n\t\tcaptureEnemy: (enemy) ->\n\t\t\t@enemy = enemy\n\t\tdamage: ->\n\t\t\t#if @dasheSp > 0.1\n\t\t\tss = 2\n\t\t\tif @enemy.dasheSp > 0.002\n\t\t\t\tss *= 2.0\n\t\t\tif @dasheSp > 0.002\n\t\t\t\tss *= 4.0\n\t\t\t@life -= 8 * ss\n\t\tact: ->\n\t\t\t# check life\n\t\t\tif @life < 0 and @reflection isnt \"\"\n\t\t\t\t@reflectTo(\"knockOut\", 10)\n\t\t\tif @enemy < 0 and @reflectTo isnt \"\"\n\t\t\t\t@reflectTo(\"nop\", 3)\n\n\t\t\t@dasheSp *= 0.7\n\t\t\t@knockBackSp *= 0.7\n\t\t\t@reflectCnt--\n\t\t\tif @reflectCnt > 0\n\t\t\t\tHand.prototype[@reflection].apply(this, null)\n\t\t\telse\n\t\t\t\tHand.prototype[@will].apply(this, null)\n\n\t\t\t@p[0] += @dasheSp\n\t\t\t@p[0] += @knockBackSp\n\t\treborn: ->\n\t\t\t@p[0] = @enemy.p[0] + @enemy.direction * 0.7\n\t\t\t@p[1] = 0.08 - 0.15\n\t\t\t@reflectTo(\"reborning\", 10)\n\t\t\t@heal()\n\t\theal: ->\n\t\t\t@life = 256\n\t\t\t@knockOutCnt = 0\n\t\treborning: ->\n\t\t\t@p[1] += 0.1\n\t\twillTo: (will) ->\n\t\t\t@will = will\n\t\treflectTo: (reflection, reflectCnt) ->\n\t\t\t@reflection = reflection\n\t\t\t@reflectCnt = reflectCnt\n\t\t# transform to pose state\n\t\ttransform: (pose) -> \n\t\t\t@pose = pose\n\t\t# no operation (dummy phase)\n\t\tnop: ->\n\t\tdashe: ->\n\t\t\tif @dasheSp.abs() < 0.01\n\t\t\t\t@dasheSp += 0.08 * @direction\n\t\tbackSteppo: ->\n\t\t\tif @dasheSp.abs() < 0.01\n\t\t\t\t@dasheSp -= 0.04 * @direction\n\t\tmoveBack: ->\n\t\t\t@p[0] +=-@sp * @direction\n\t\tmoveFront: ->\n\t\t\t@p[0] += @sp * @direction\n\t\tweakKnockBack: ->\n\t\t\t@knockBackSp = -0.05 * @direction\n\t\t\t@reflectTo(\"nop\", 3)\n\t\tknockBack: ->\n\t\t\t@knockBackSp = -0.1 * @direction\n\t\t\t@reflectTo(\"nop\", 3)\n\t\tknockOut: ->\n\t\t\t# i can fly!\n\t\t\t@p[0] -= 0.05 * @direction\n\t\t\t@p[1] -= 0.05\n\t\t\t@knockOutCnt++\n\t\tdraw: ->\n\t\t\td\n\t\t\t .drawImage(@images[@pose], [0, 0], [1, 1], @p, @s)\n\n\t# janken judge result\n\tJudge =\n\t\tDraw: 0\n\t\tLose: 1\n\t\tWin: 2\n\n\t# judge a win/draw/lose\n\tclass Judgement\n\t\tconstructor: ->\n\t\t\t@se_lose = new Audio(\"http://dl.dropbox.com/u/3589634/resource/se/se_lose.ogg\")\n\t\t\t@se_draw = new Audio(\"http://dl.dropbox.com/u/3589634/resource/se/se_draw.ogg\")\n\t\t\t@se_win = new Audio(\"http://dl.dropbox.com/u/3589634/resource/se/se_win.ogg\")\n\t\tplayOgg: (audio) ->\n\t\t\tif audio.currentTime\n\t\t\t\taudio.pause()\n\t\t\t\taudio.currentTime = 0\n\t\t\taudio.play()\n\t\tjudge: (self, enemy) ->\n\t\t\t(self.pose - enemy.pose + Pose.Size) % Pose.Size\n\t\ttellMeHowToWin: (enemy) ->\n\t\t\t(enemy.pose + 2 + Pose.Size) % Pose.Size\n\t\ttellMeHowToLose: (enemy) ->\n\t\t\t(enemy.pose + 1 + Pose.Size) % Pose.Size\n\t\tcaptureHands: (hand1, hand2) ->\n\t\t\t@hand1 = hand1\n\t\t\t@hand2 = hand2\n\t\tcaptureStage: (stage) ->\n\t\t\t@stage = stage\n\t\thitTest: ->\n\t\t\t# be collisioned!\n\t\t\tif (@hand1.p[0] - @hand2.p[0]).abs() < (@hand1.s[0] + @hand2.s[1]) / 2 / 2\n\t\t\t\tsignBase = (@hand1.p[0] - @hand2.p[0]).sign()\n\t\t\t\t# judge\n\t\t\t\tresult = @judge(@hand1, @hand2)\n\t\t\t\tif result is Judge.Draw\n\t\t\t\t\t@hand1.knockBack()\n\t\t\t\t\t@hand2.knockBack()\n\t\t\t\t\t@playOgg(@se_draw)\n\t\t\t\telse if result is Judge.Lose\n\t\t\t\t\t@hand1.knockBack()\n\t\t\t\t\t@hand1.damage()\n\t\t\t\t\t@hand2.weakKnockBack()\n\t\t\t\t\t@stage.shock()\n\t\t\t\t\t@stage.damaged()\n\t\t\t\t\t@playOgg(@se_lose)\n\t\t\t\telse if result is Judge.Win\n\t\t\t\t\t@hand1.weakKnockBack()\n\t\t\t\t\t@hand2.knockBack()\n\t\t\t\t\t@hand2.damage()\n\t\t\t\t\t@stage.shock()\n\t\t\t\t\t@playOgg(@se_win)\n\n\n\t# Player class\n\tclass Player extends Hand\n\t\tconstructor: ->\n\t\t\tsuper(0.1, 1)\n\n\t# Cpu class\n\tclass Cpu extends Hand\n\t\tconstructor: ->\n\t\t\t# action\n\t\t\t@willTo(\"moveFront\")\n\t\t\t# if this value is 0, make decision\n\t\t\t@nextDecition = 0\n\t\t\t@setParam()\n\n\t\t\tsuper(0.7, -1)\n\t\tsetParam: (clock=12,p1=5, p2=5,p3=0.1) ->\n\t\t\t@clock = 12\n\t\t\t@p1 = p1\n\t\t\t@p2 = p2\n\t\t\t@p3 = p3\n\t\twillTo: (will) ->\n\t\t\tsuper(will)\n\t\tmakeDecision: ->\n\t\t\tsimulate = @judgement.judge(this, @enemy)\n\t\t\tif simulate is Judge.Lose\n\t\t\t\tif not (@clock * @p1 * 1 .rand())\n\t\t\t\t\t@pose = @judgement.tellMeHowToWin(@enemy)\n\t\t\t\t\n\t\t\tdistance = (@enemy.p[0] - @p[0]).abs()\n\t\t\t# dashe\n\t\t\tif distance > 0.8\n\t\t\t\tif 1 .randf() < 0.5\n\t\t\t\t\t@willTo(\"dashe\")\n\t\t\telse if distance.abs() > 0.3\n\t\t\t\tif 1 .randf() < 0.2\n\t\t\t\t\t# hardly back step\n\t\t\t\t\t@willTo(\"moveBack\")\n\t\t\t\telse\n\t\t\t\t\t@willTo(\"moveFront\")\n\t\t\telse\n\t\t\t\t# in range dashe or back\n\t\t\t\tif 1 .randf() < @p3\n\t\t\t\t\t@willTo(\"dashe\")\n\t\t\t\telse\n\t\t\t\t\t@willTo(\"moveBack\")\n\t\t\t\t\t# and transform to lose pose randomly\n\t\t\t\t\tif 1 .randf() < @p2\n\t\t\t\t\t\t@pose = @judgement.tellMeHowToLose(@enemy)\n\n\t\t\t# override will randomly\n\t\t\tif 1 .randf() < 0.1\n\t\t\t\t@willTo(\"moveBack moveFront dashe moveBack nop\".split(\" \").randomSelect())\n\n\t\t\t# change pose randomly\n\t\t\tif 1 .randf() < 0.1\n\t\t\t\t@transform([Pose.Rock, Pose.Scissors, Pose.Paper].randomSelect())\n\t\tact: ->\n\t\t\t# decision time\n\t\t\tif @nextDecition <= 0\n\t\t\t\t@makeDecision()\n\t\t\t\t@nextDecition += @clock * $R(0, 2).rand()\n\n\t\t\t@nextDecition--\n\n\t\t\tif @p[0] < @enemy.p[0]\n\t\t\t\t@p[0] = @enemy.p[0] + 0.01\n\n\t\t\tsuper\n\n\n\t# phase a base class of vary phase...?\n\tclass Phase\n\t\tactivateFrom: (from) ->\n\t\t\t@kb = from.kb\n\t\t\t@judgement = from.judgement\n\t\t\t@player = from.player\n\t\t\t@cpu = from.cpu\n\t\t\t@stage = from.stage\n\t\t\t@lv = from.lv\n\n\t# dummy phase for initializing instances variables\n\tclass PhaseInitialize extends Phase\n\t\tinitialize: ->\n\t\t\t@kb = new Keyboard()\n\t\t\t'37 39 X Y Z V'.split(' ').each (x) =>\n\t\t\t\t@kb.at(x).enablePrevent()\n\n\t\t\t# create instances\n\t\t\t@judgement = new Judgement()\n\t\t\t@player = new Player()\n\t\t\t@cpu = new Cpu()\n\t\t\t@stage = new Stage()\n\n\t\t\t# set up\n\t\t\t@player.transform(Pose.Rock)\n\t\t\t@cpu.transform(Pose.Rock)\n\n\t\t\t@judgement.captureHands(@player, @cpu)\n\t\t\t@judgement.captureStage(@stage)\n\t\t\t@player.captureJudgement(@judgement)\n\t\t\t@player.captureEnemy(@cpu)\n\t\t\t@cpu.captureJudgement(@judgement)\n\t\t\t@cpu.captureEnemy(@player)\n\t\t\t@stage.captureHands(@player, @cpu)\n\n\t\t\t@lv = 1\n\n\t# on opening phase\n\tclass PhaseOpening extends Phase\n\t\tinitialize: ->\n\t\t\t@stage.reset()\n\t\t\tps = [\n\t\t\t\t[5, 2, 0.1],\n\t\t\t\t[8, 2, 0.1],\n\t\t\t\t[5, 4, 0.1],\n\t\t\t\t[5, 2, 0.2],\n\t\t\t].randomSelect()\n\t\t\t@cpu.setParam(128 / (@lv + 8), ps[0], ps[1], ps[2])\n\t\t\t@count = 0\n\t\t\t@maxFrame = 40\n\n\t\t\t@prefix = \"\"\n\n\t\tmain: ->\n\t\t\t@kb.flush()\n\t\t\t# init background\n\t\t\t@stage.act()\n\t\t\t@stage.draw()\n\n\t\t\t@player.willTo(\"nop\")\n\n\t\t\t# act\n\t\t\tif @kb.at(37).pressing\n\t\t\t\t@player.willTo(\"moveBack\")\n\n\t\t\t# right key\n\t\t\tif @kb.at(39).pressing\n\t\t\t\t@player.willTo(\"moveFront\")\n\n\t\t\t@player.act()\n\t\t\t@cpu.act()\n\n\t\t\t# draw player, cpu\n\t\t\t@stage.delegateDraw false, () =>\n\t\t\t\t@player.draw()\n\t\t\t\t@cpu.draw()\n\n\t\t\t@count++\n\n\t\t\t# draw title\n\t\t\td\n\t\t\t .rgb(0x00, 0x00, 0x00)\n\t\t\t .alpha(0.5)\n\t\t\t .blend(\"source-over\")\n\t\t\t .rect([0, 0.4], [1, 0.2])\n\t\t\t .fill()\n\n\t\t\t# VS\n\t\t\td\n\t\t\t .alpha(1)\n\t\t\t .rgb(0xff, 0xff, 0xff)\n\t\t\t .textBaseline(\"middle\")\n\t\t\t .textAlign(\"center\")\n\t\t\t .font(\"cursive\", 0.2, \"italic\")\n\t\t\t .fillText(\"VS - \" + \"LV.\" + @lv, [0.5, 0.5])\n\n\n\t\t\tlen = @count / @maxFrame\n\t\t\td\n\t\t\t .alpha(0.5)\n\t\t\t .rgb(0xff, 0x00, 0x00)\n\t\t\t .rect([1 - len, 0.4], [len, 0.01])\n\t\t\t .fill()\n\t\t\t .rect([0, 0.6], [len, 0.01])\n\t\t\t .fill()\n\n\t\t\t# reset\n\t\t\td\n\t\t\t .alpha(1)\n\n\t\t\tif @count > @maxFrame\n\t\t\t\treturn new PhaseFighting()\n\n\n\t\t\tthis\n\n\t# on fighting phase\n\tclass PhaseFighting extends Phase\n\t\t\n\t\tinitialize: ->\n\n\t\tmain: ->\n\n\t\t\t@kb.flush()\n\n\t\t\t# init background\n\t\t\t@stage.act()\n\t\t\t@stage.draw()\n\n\t\t\t## user control\n\n\t\t\t# default\n\t\t\t@player.willTo(\"nop\")\n\n\t\t\t# left key\n\t\t\tif @kb.at(37).pressing\n\t\t\t\tif @kb.at('V').downed\n\t\t\t\t\t@player.willTo(\"backSteppo\")\n\t\t\t\telse\n\t\t\t\t\t@player.willTo(\"moveBack\")\n\n\t\t\t# right key\n\t\t\tif @kb.at(39).pressing\n\t\t\t\tif @kb.at('V').downed\n\t\t\t\t\t@player.willTo(\"dashe\")\n\t\t\t\telse\n\t\t\t\t\t@player.willTo(\"moveFront\")\n\n\t\t\t# pose\n\t\t\tif @kb.at('Z').downed\n\t\t\t\t@player.transform(Pose.Rock)\n\t\t\tif @kb.at('X').downed\n\t\t\t\t@player.transform(Pose.Scissors)\n\t\t\tif @kb.at('C').downed\n\t\t\t\t@player.transform(Pose.Paper)\n\n\t\t\t# player phase\n\t\t\t@player.act()\n\t\t\t# cpu phase\n\t\t\t@cpu.act()\n\n\t\t\t# draw player, cpu\n\t\t\t@stage.delegateDraw false, () =>\n\t\t\t\t@player.draw()\n\t\t\t\t@cpu.draw()\n\n\t\t\t@judgement.hitTest()\n\n\t\t\t# show life\n\t\t\t@stage.delegateDraw true, () =>\n\t\t\t\t# player\n\t\t\t\td\n\t\t\t\t .blend(\"source-over\")\n\t\t\t\t .alpha(0.8)\n\t\t\t\t .gradient([0, 0], [1, 0], [\n\t\t\t\t\t [0, [0xff, 0x00, 0x00]],\n\t\t\t\t\t [1, [0x99, 0x99, 0xff]],\n\t\t\t\t ])\n\n\t\t\t\t# player\n\t\t\t\td\n\t\t\t\t .rect([0, 0.02], [@player.life / 256, 0.01])\n\t\t\t\t .fill()\n\n\t\t\t\t# cpu\n\t\t\t\td\n\t\t\t\t .rect([0.0, 0.05], [@cpu.life / 256, 0.01])\n\t\t\t\t .fill()\n\n\t\t\t\t# reset draw mode\n\t\t\t\td\n\t\t\t\t .blend(\"source-over\")\n\t\t\t\t .alpha(1.0)\n\n\n\t\t\t# observe knock out\n\t\t\t# reborn and goto opening phase on counter is over\n\n\t\t\t# player won\n\t\t\tif @cpu.knockOutCnt > 45\n\t\t\t\t@cpu.reborn()\n\t\t\t\t@player.heal()\n\t\t\t\t@cpu.heal()\n\t\t\t\t@lv++\n\t\t\t\tnew PhaseOpening()\n\t\t\t# cpu won\n\t\t\telse if @player.knockOutCnt > 45\n\t\t\t\t@player.reborn()\n\t\t\t\t@player.heal()\n\t\t\t\t@cpu.heal()\n\t\t\t\t@lv -= 3\n\t\t\t\t@lv = 1 if @lv <= 0\n\t\t\t\tnew PhaseOpening()\n\t\t\telse\n\t\t\t\tthis\n\n\n\tprevPhase = new PhaseInitialize()\n\tprevPhase.initialize()\n\tphase = new PhaseOpening()\n\n\t# main loop\n\tmain = (c = 0) ->\n\t\tif(phase isnt prevPhase)\n\t\t\tphase.activateFrom(prevPhase)\n\t\t\tphase.initialize()\n\t\tprevPhase = phase\n\t\tphase = phase.main()\n\t\tsetTimeout(arguments.callee.curry(c + 1), 33)\n\n\tmain()\n\n# vim:sw=2:ts=2\n"},"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/1/Q/x/1Qx3_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/1/Q/x/1Qx3.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/1/Q/x/1Qx3_100.jpg"},"description_html":"格闘ゲームは高速でジャンケン繰り出しているのと同じみたいな例えがありますが、逆は成り立つのかと考えました。<br />\r\n<br />\r\n＊操作<br />\r\nカーソル右、左：　キャラ移動<br />\r\n移動中にVキー:　ダッシュ、バックステッポ<br />\r\nZ, X, Cキー：　ぐー、ちょき、ぱー<br />\r\n<br />\r\n＊ルール<br />\r\nダメージ判定は、一般的なジャンケンと同じルールです。<br />\r\nダッシュ中は捨て身になり、攻撃力二倍、受けるダメージ四倍になります。<br />\r\n<br />\r\n一応、CPUのAIにレベルがあります。<br />\r\n勝つとレベルアップ、負けるとレベル３ダウン。<br />\r\n演出ないからわかりにくい。<br />\r\n<br />\r\n＊あと<br />\r\n音は魔王魂さんからお借りしてます<br />\r\n<a  href=\"http://maoudamashii.jokersounds.com/music_se.html\">http://maoudamashii.jokersounds.com/music_se.html</a>","parent":{"thumbnail":{"wide":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/e/s/T/esTj_w.jpg","465":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/e/s/T/esTj.jpg","100":"http://jsdo-static-contents.s3.amazonaws.com/images/capture/e/s/T/esTj_100.jpg"},"modified_date":"2012-10-22 09:47:23","uid":"esTj","created_date":"2012-10-18 11:09:15","path":"esTj","description":"<a href=\"http://jsdo.it/event/html5csc/vol1/\" target=\"_blank\">http://jsdo.it/event/html5csc/vol1/</a>\r\n\r\nこのコードは、第一回全国統一 HTML5実技コンテストのエントリー用コードです。  \r\nサイトからエントリーをし、こちらのコードをフォークしてください。\r\n\r\n-------------------------\r\n\r\n##お題：HTML5で夢中にさせる「じゃんけんゲーム」\r\n\r\nHTML5で、つい夢中にさせるじゃんけんゲームの表現にチャレンジしてください。  \r\nじゃんけんのルールをそのままに、あなたなりの演出を加えても良いですし、  \r\n一部ルールを差し替えて新しいゲームとして生まれ変わらせても構いません。   \r\n夢中になり、ついつい何回も操作してしまうゲーム性のある投稿をお待ちしています。  \r\n主に、企画力や発想力を評価します。自由な発想をお待ちしています！","statistic":{"forked":"181","favorite":"1","pageview":"41934"},"user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/6/7/b/5/67b56e45ea501eedd27eec70435d26553c0eace6_100.jpg","name":"jsdo.it_team"},"url":"http://jsdo.it/jsdo.it_team/esTj","title":"第一回全国統一 HTML5実技コンテスト エントリー用コード"},"modified_date":"2012-11-07 23:55:27","uid":"1Qx3","created_date":"2012-11-04 23:56:22","path":"1Qx3","description":"格闘ゲームは高速でジャンケン繰り出しているのと同じみたいな例えがありますが、逆は成り立つのかと考えました。\r\n\r\n＊操作\r\nカーソル右、左：　キャラ移動\r\n移動中にVキー:　ダッシュ、バックステッポ\r\nZ, X, Cキー：　ぐー、ちょき、ぱー\r\n\r\n＊ルール\r\nダメージ判定は、一般的なジャンケンと同じルールです。\r\nダッシュ中は捨て身になり、攻撃力二倍、受けるダメージ四倍になります。\r\n\r\n一応、CPUのAIにレベルがあります。\r\n勝つとレベルアップ、負けるとレベル３ダウン。\r\n演出ないからわかりにくい。\r\n\r\n＊あと\r\n音は魔王魂さんからお借りしてます\r\nhttp://maoudamashii.jokersounds.com/music_se.html","statistic":{"forked":"0","favorite":"1","pageview":"1548"},"url":"http://jsdo.it/crispy/1Qx3","user":{"icon":"http://jsdo-static-contents.s3.amazonaws.com/images/icon/b/4/2/c/b42cc3dd3312505b680411b3ead08e2dbc4192e4_100.jpg","name":"crispy"},"title":"格闘ゲーム"}